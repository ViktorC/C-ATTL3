<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C-ATTL3: cattle::LSTMNeuralNetwork&lt; Scalar, Rank, MulInt, Stateful &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C-ATTL3
   &#160;<span id="projectnumber">0.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecattle.html">cattle</a></li><li class="navelem"><a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html">LSTMNeuralNetwork</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classcattle_1_1_l_s_t_m_neural_network-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cattle::LSTMNeuralNetwork&lt; Scalar, Rank, MulInt, Stateful &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class template representing a long-short term memory (LSTM) recurrent neural network.  
 <a href="classcattle_1_1_l_s_t_m_neural_network.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_l_s_t_m_neural_network_8hpp_source.html">LSTMNeuralNetwork.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cattle::LSTMNeuralNetwork&lt; Scalar, Rank, MulInt, Stateful &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcattle_1_1_l_s_t_m_neural_network.png" usemap="#cattle::LSTMNeuralNetwork_3C_20Scalar_2C_20Rank_2C_20MulInt_2C_20Stateful_20_3E_map" alt=""/>
  <map id="cattle::LSTMNeuralNetwork_3C_20Scalar_2C_20Rank_2C_20MulInt_2C_20Stateful_20_3E_map" name="cattle::LSTMNeuralNetwork_3C_20Scalar_2C_20Rank_2C_20MulInt_2C_20Stateful_20_3E_map">
<area href="classcattle_1_1_unidirectional_neural_network.html" title="An abstract class template for unidirectional recurrent neural networks. " alt="cattle::UnidirectionalNeuralNetwork&lt; Scalar, Rank &gt;" shape="rect" coords="0,56,357,80"/>
<area href="classcattle_1_1_neural_network.html" alt="cattle::NeuralNetwork&lt; Scalar, Rank, true &gt;" shape="rect" coords="0,0,357,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a74762580716e4c536e7c47aa15c0a0c0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html#a74762580716e4c536e7c47aa15c0a0c0">LSTMNeuralNetwork</a> (<a class="el" href="namespacecattle.html#a540d630253530c3530f6af1c31b82c44">KernelPtr</a>&lt; Scalar, Rank &gt; &amp;&amp;input_forget_kernel, <a class="el" href="namespacecattle.html#a540d630253530c3530f6af1c31b82c44">KernelPtr</a>&lt; Scalar, Rank &gt; &amp;&amp;output_forget_kernel, <a class="el" href="namespacecattle.html#a540d630253530c3530f6af1c31b82c44">KernelPtr</a>&lt; Scalar, Rank &gt; &amp;&amp;input_write_kernel, <a class="el" href="namespacecattle.html#a540d630253530c3530f6af1c31b82c44">KernelPtr</a>&lt; Scalar, Rank &gt; &amp;&amp;output_write_kernel, <a class="el" href="namespacecattle.html#a540d630253530c3530f6af1c31b82c44">KernelPtr</a>&lt; Scalar, Rank &gt; &amp;&amp;input_candidate_kernel, <a class="el" href="namespacecattle.html#a540d630253530c3530f6af1c31b82c44">KernelPtr</a>&lt; Scalar, Rank &gt; &amp;&amp;output_candidate_kernel, <a class="el" href="namespacecattle.html#a540d630253530c3530f6af1c31b82c44">KernelPtr</a>&lt; Scalar, Rank &gt; &amp;&amp;input_read_kernel, <a class="el" href="namespacecattle.html#a540d630253530c3530f6af1c31b82c44">KernelPtr</a>&lt; Scalar, Rank &gt; &amp;&amp;output_read_kernel, <a class="el" href="namespacecattle.html#a33c43d0983f054e904daa2806ce17231">ActivationPtr</a>&lt; Scalar, Rank &gt; &amp;&amp;forget_act, <a class="el" href="namespacecattle.html#a33c43d0983f054e904daa2806ce17231">ActivationPtr</a>&lt; Scalar, Rank &gt; &amp;&amp;write_act, <a class="el" href="namespacecattle.html#a33c43d0983f054e904daa2806ce17231">ActivationPtr</a>&lt; Scalar, Rank &gt; &amp;&amp;candidate_act, <a class="el" href="namespacecattle.html#a33c43d0983f054e904daa2806ce17231">ActivationPtr</a>&lt; Scalar, Rank &gt; &amp;&amp;state_act, <a class="el" href="namespacecattle.html#a33c43d0983f054e904daa2806ce17231">ActivationPtr</a>&lt; Scalar, Rank &gt; &amp;&amp;read_act, OutputSeqSizeFunc output_seq_size_func, bool reversed=false, bool foremost=true)</td></tr>
<tr class="separator:a74762580716e4c536e7c47aa15c0a0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe39bea97e1f01279024a8d2a2adbba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcattle_1_1_neural_network.html">Root</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html#acfe39bea97e1f01279024a8d2a2adbba">clone</a> () const</td></tr>
<tr class="memdesc:acfe39bea97e1f01279024a8d2a2adbba"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant method implementing the clone pattern.  <a href="#acfe39bea97e1f01279024a8d2a2adbba">More...</a><br /></td></tr>
<tr class="separator:acfe39bea97e1f01279024a8d2a2adbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83421c050b636f88c130cf98cb90f2e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html#a83421c050b636f88c130cf98cb90f2e1">is_reversed</a> () const</td></tr>
<tr class="separator:a83421c050b636f88c130cf98cb90f2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9501074043d5ea041ed5cd58767c3754"><td class="memItemLeft" align="right" valign="top"><a id="a9501074043d5ea041ed5cd58767c3754"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html#a9501074043d5ea041ed5cd58767c3754">reverse</a> ()</td></tr>
<tr class="memdesc:a9501074043d5ea041ed5cd58767c3754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips the direction along the time-step rank in which the network processes its inputs is reversed. <br /></td></tr>
<tr class="separator:a9501074043d5ea041ed5cd58767c3754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515956ee97a9f94a2a9001f5ae4bedbf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcattle_1_1_dimensions.html">Root::Dims</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html#a515956ee97a9f94a2a9001f5ae4bedbf">get_input_dims</a> () const</td></tr>
<tr class="separator:a515956ee97a9f94a2a9001f5ae4bedbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10aa3773f5b55532301a6301d9d2cad"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcattle_1_1_dimensions.html">Root::Dims</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html#ae10aa3773f5b55532301a6301d9d2cad">get_output_dims</a> () const</td></tr>
<tr class="separator:ae10aa3773f5b55532301a6301d9d2cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de6fa957b2a3fb27771f7e2ef8da72c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const <a class="el" href="classcattle_1_1_layer.html">Layer</a>&lt; Scalar, Rank &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html#a7de6fa957b2a3fb27771f7e2ef8da72c">get_layers</a> () const</td></tr>
<tr class="separator:a7de6fa957b2a3fb27771f7e2ef8da72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d781209f6bee0f3c837e625bbf5ea7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcattle_1_1_layer.html">Layer</a>&lt; Scalar, Rank &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html#a24d781209f6bee0f3c837e625bbf5ea7">get_layers</a> ()</td></tr>
<tr class="separator:a24d781209f6bee0f3c837e625bbf5ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746769e064f987a44c14c555123a9f6a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html#a746769e064f987a44c14c555123a9f6a">is_foremost</a> () const</td></tr>
<tr class="separator:a746769e064f987a44c14c555123a9f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392e844c1364349e02be4b0ff8d20b02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html#a392e844c1364349e02be4b0ff8d20b02">set_foremost</a> (bool foremost)</td></tr>
<tr class="memdesc:a392e844c1364349e02be4b0ff8d20b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the foremost status of the network.  <a href="#a392e844c1364349e02be4b0ff8d20b02">More...</a><br /></td></tr>
<tr class="separator:a392e844c1364349e02be4b0ff8d20b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a14214bf76f4510c21116d07bda8ba4"><td class="memItemLeft" align="right" valign="top"><a id="a5a14214bf76f4510c21116d07bda8ba4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html#a5a14214bf76f4510c21116d07bda8ba4">empty_caches</a> ()</td></tr>
<tr class="memdesc:a5a14214bf76f4510c21116d07bda8ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empties the caches of every layer of the network. <br /></td></tr>
<tr class="separator:a5a14214bf76f4510c21116d07bda8ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06041a938c2b82c3cbbee3545e7f904f"><td class="memItemLeft" align="right" valign="top">Root::Data&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html#a06041a938c2b82c3cbbee3545e7f904f">propagate</a> (typename Root::Data input, bool training)</td></tr>
<tr class="memdesc:a06041a938c2b82c3cbbee3545e7f904f"><td class="mdescLeft">&#160;</td><td class="mdescRight">It propagates the input tensor through the network and outputs its prediction.  <a href="#a06041a938c2b82c3cbbee3545e7f904f">More...</a><br /></td></tr>
<tr class="separator:a06041a938c2b82c3cbbee3545e7f904f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a6425deae97b7a267628eb4c4dd251"><td class="memItemLeft" align="right" valign="top">Root::Data&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html#a84a6425deae97b7a267628eb4c4dd251">backpropagate</a> (typename Root::Data out_grad)</td></tr>
<tr class="memdesc:a84a6425deae97b7a267628eb4c4dd251"><td class="mdescLeft">&#160;</td><td class="mdescRight">It back-propagates the derivative of the loss function w.r.t.  <a href="#a84a6425deae97b7a267628eb4c4dd251">More...</a><br /></td></tr>
<tr class="separator:a84a6425deae97b7a267628eb4c4dd251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcattle_1_1_neural_network"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcattle_1_1_neural_network')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcattle_1_1_neural_network.html">cattle::NeuralNetwork&lt; Scalar, Rank, true &gt;</a></td></tr>
<tr class="memitem:a3603ff7538a781c451796463b00e7eec inherit pub_methods_classcattle_1_1_neural_network"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const Parameters&lt; Scalar &gt; *&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_neural_network.html#a3603ff7538a781c451796463b00e7eec">get_all_params</a> () const</td></tr>
<tr class="separator:a3603ff7538a781c451796463b00e7eec inherit pub_methods_classcattle_1_1_neural_network"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afadc71d57e50328c50e6114ed30fc308 inherit pub_methods_classcattle_1_1_neural_network"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Parameters&lt; Scalar &gt; *&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_neural_network.html#afadc71d57e50328c50e6114ed30fc308">get_all_params</a> ()</td></tr>
<tr class="separator:afadc71d57e50328c50e6114ed30fc308 inherit pub_methods_classcattle_1_1_neural_network"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1db5849f0a79739514a0b42a89cefb7 inherit pub_methods_classcattle_1_1_neural_network"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const Parameters&lt; Scalar &gt; *&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_neural_network.html#ae1db5849f0a79739514a0b42a89cefb7">get_all_unique_params</a> () const</td></tr>
<tr class="separator:ae1db5849f0a79739514a0b42a89cefb7 inherit pub_methods_classcattle_1_1_neural_network"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc3d097c8c4f01e76499f55b30ad0c2 inherit pub_methods_classcattle_1_1_neural_network"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Parameters&lt; Scalar &gt; *&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_neural_network.html#adcc3d097c8c4f01e76499f55b30ad0c2">get_all_unique_params</a> ()</td></tr>
<tr class="separator:adcc3d097c8c4f01e76499f55b30ad0c2 inherit pub_methods_classcattle_1_1_neural_network"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a8c8170471486c5f10ba09a5709ad6 inherit pub_methods_classcattle_1_1_neural_network"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_neural_network.html#a94a8c8170471486c5f10ba09a5709ad6">set_frozen</a> (bool frozen)</td></tr>
<tr class="memdesc:a94a8c8170471486c5f10ba09a5709ad6 inherit pub_methods_classcattle_1_1_neural_network"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all parameters of the network to the specified frozens state.  <a href="classcattle_1_1_neural_network.html#a94a8c8170471486c5f10ba09a5709ad6">More...</a><br /></td></tr>
<tr class="separator:a94a8c8170471486c5f10ba09a5709ad6 inherit pub_methods_classcattle_1_1_neural_network"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59c0963d75b1f2de4f18a6c8fe85fa8 inherit pub_methods_classcattle_1_1_neural_network"><td class="memItemLeft" align="right" valign="top"><a id="ae59c0963d75b1f2de4f18a6c8fe85fa8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_neural_network.html#ae59c0963d75b1f2de4f18a6c8fe85fa8">init</a> ()</td></tr>
<tr class="memdesc:ae59c0963d75b1f2de4f18a6c8fe85fa8 inherit pub_methods_classcattle_1_1_neural_network"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes all parameters of the network. <br /></td></tr>
<tr class="separator:ae59c0963d75b1f2de4f18a6c8fe85fa8 inherit pub_methods_classcattle_1_1_neural_network"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88007e2f8fa2a208de0e51c8ac422cc inherit pub_methods_classcattle_1_1_neural_network"><td class="memItemLeft" align="right" valign="top">virtual Data&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_neural_network.html#ac88007e2f8fa2a208de0e51c8ac422cc">infer</a> (Data input)</td></tr>
<tr class="memdesc:ac88007e2f8fa2a208de0e51c8ac422cc inherit pub_methods_classcattle_1_1_neural_network"><td class="mdescLeft">&#160;</td><td class="mdescRight">It propagates the input through the neural network and outputs its prediction according to its current parameters.  <a href="classcattle_1_1_neural_network.html#ac88007e2f8fa2a208de0e51c8ac422cc">More...</a><br /></td></tr>
<tr class="separator:ac88007e2f8fa2a208de0e51c8ac422cc inherit pub_methods_classcattle_1_1_neural_network"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad21fd14d656e68592c20e3278464085f inherit pub_methods_classcattle_1_1_neural_network"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_neural_network.html#ad21fd14d656e68592c20e3278464085f">save_all_unique_params_values</a> (const std::string &amp;dir_path, bool binary=true, const std::string &amp;file_name_prefix=PARAM_SERIAL_PREFIX) const</td></tr>
<tr class="memdesc:ad21fd14d656e68592c20e3278464085f inherit pub_methods_classcattle_1_1_neural_network"><td class="mdescLeft">&#160;</td><td class="mdescRight">It serializes the values of the unique parameters of the network into files in a specified folder.  <a href="classcattle_1_1_neural_network.html#ad21fd14d656e68592c20e3278464085f">More...</a><br /></td></tr>
<tr class="separator:ad21fd14d656e68592c20e3278464085f inherit pub_methods_classcattle_1_1_neural_network"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fbee7dab410602dffb9848b0a938525 inherit pub_methods_classcattle_1_1_neural_network"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_neural_network.html#a3fbee7dab410602dffb9848b0a938525">load_all_unique_params_values</a> (const std::string &amp;dir_path, bool binary=true, const std::string &amp;file_name_prefix=PARAM_SERIAL_PREFIX)</td></tr>
<tr class="memdesc:a3fbee7dab410602dffb9848b0a938525 inherit pub_methods_classcattle_1_1_neural_network"><td class="mdescLeft">&#160;</td><td class="mdescRight">It sets the values of the unique parameters of the network from files containing serialized parameter values.  <a href="classcattle_1_1_neural_network.html#a3fbee7dab410602dffb9848b0a938525">More...</a><br /></td></tr>
<tr class="separator:a3fbee7dab410602dffb9848b0a938525 inherit pub_methods_classcattle_1_1_neural_network"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classcattle_1_1_unidirectional_neural_network"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classcattle_1_1_unidirectional_neural_network')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classcattle_1_1_unidirectional_neural_network.html">cattle::UnidirectionalNeuralNetwork&lt; Scalar, Rank &gt;</a></td></tr>
<tr class="memitem:ad7c71f700c1ac964c6a10a0864b5589a inherit pub_static_methods_classcattle_1_1_unidirectional_neural_network"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_unidirectional_neural_network.html#ad7c71f700c1ac964c6a10a0864b5589a">reverse_along_time_axis</a> (typename Base::Data &amp;tensor)</td></tr>
<tr class="memdesc:ad7c71f700c1ac964c6a10a0864b5589a inherit pub_static_methods_classcattle_1_1_unidirectional_neural_network"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses a tensor along its time axis.  <a href="classcattle_1_1_unidirectional_neural_network.html#ad7c71f700c1ac964c6a10a0864b5589a">More...</a><br /></td></tr>
<tr class="separator:ad7c71f700c1ac964c6a10a0864b5589a inherit pub_static_methods_classcattle_1_1_unidirectional_neural_network"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Scalar, std::size_t Rank, bool MulInt = false, bool Stateful = false&gt;<br />
class cattle::LSTMNeuralNetwork&lt; Scalar, Rank, MulInt, Stateful &gt;</h3>

<p>A class template representing a long-short term memory (LSTM) recurrent neural network. </p>
<p>The network can use multiplicative integration to combine its linearly transformed inputs and its linearly transformed hidden outputs. A stateful network retains its hidden state across sequences as long as the batch size is constant.</p>
<dl class="section see"><dt>See also</dt><dd><a href="http://www.bioinf.jku.at/publications/older/2604.pdf">http://www.bioinf.jku.at/publications/older/2604.pdf</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a74762580716e4c536e7c47aa15c0a0c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74762580716e4c536e7c47aa15c0a0c0">&#9670;&nbsp;</a></span>LSTMNeuralNetwork()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , std::size_t Rank, bool MulInt = false, bool Stateful = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html">cattle::LSTMNeuralNetwork</a>&lt; Scalar, Rank, MulInt, Stateful &gt;::<a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html">LSTMNeuralNetwork</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecattle.html#a540d630253530c3530f6af1c31b82c44">KernelPtr</a>&lt; Scalar, Rank &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>input_forget_kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecattle.html#a540d630253530c3530f6af1c31b82c44">KernelPtr</a>&lt; Scalar, Rank &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>output_forget_kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecattle.html#a540d630253530c3530f6af1c31b82c44">KernelPtr</a>&lt; Scalar, Rank &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>input_write_kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecattle.html#a540d630253530c3530f6af1c31b82c44">KernelPtr</a>&lt; Scalar, Rank &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>output_write_kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecattle.html#a540d630253530c3530f6af1c31b82c44">KernelPtr</a>&lt; Scalar, Rank &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>input_candidate_kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecattle.html#a540d630253530c3530f6af1c31b82c44">KernelPtr</a>&lt; Scalar, Rank &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>output_candidate_kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecattle.html#a540d630253530c3530f6af1c31b82c44">KernelPtr</a>&lt; Scalar, Rank &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>input_read_kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecattle.html#a540d630253530c3530f6af1c31b82c44">KernelPtr</a>&lt; Scalar, Rank &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>output_read_kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecattle.html#a33c43d0983f054e904daa2806ce17231">ActivationPtr</a>&lt; Scalar, Rank &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>forget_act</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecattle.html#a33c43d0983f054e904daa2806ce17231">ActivationPtr</a>&lt; Scalar, Rank &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>write_act</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecattle.html#a33c43d0983f054e904daa2806ce17231">ActivationPtr</a>&lt; Scalar, Rank &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>candidate_act</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecattle.html#a33c43d0983f054e904daa2806ce17231">ActivationPtr</a>&lt; Scalar, Rank &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>state_act</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecattle.html#a33c43d0983f054e904daa2806ce17231">ActivationPtr</a>&lt; Scalar, Rank &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>read_act</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputSeqSizeFunc&#160;</td>
          <td class="paramname"><em>output_seq_size_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reversed</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>foremost</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_forget_kernel</td><td>The forget kernel to apply to the input of the network. </td></tr>
    <tr><td class="paramname">output_forget_kernel</td><td>The forget kernel to apply to the hidden output of the network at the previous time step. </td></tr>
    <tr><td class="paramname">input_write_kernel</td><td>The write kernel to apply to the input of the network. </td></tr>
    <tr><td class="paramname">output_write_kernel</td><td>The write kernel to apply to the hidden output of the network at the previous time step. </td></tr>
    <tr><td class="paramname">input_candidate_kernel</td><td>The candidate kernel to apply to the input of the network. </td></tr>
    <tr><td class="paramname">output_candidate_kernel</td><td>The candidate kernel to apply to the hidden output of the network at the previous time step. </td></tr>
    <tr><td class="paramname">input_read_kernel</td><td>The read kernel to apply to the input of the network. </td></tr>
    <tr><td class="paramname">output_read_kernel</td><td>The read kernel to apply to the hidden output of the network at the previous time step. </td></tr>
    <tr><td class="paramname">forget_act</td><td>The activation layer of the forget gate. Usually a sigmoid activation function. </td></tr>
    <tr><td class="paramname">write_act</td><td>The activation layer of the filter of the write gate. Usually a sigmoid activation function. </td></tr>
    <tr><td class="paramname">candidate_act</td><td>The activation layer of the candidates of the write gate. Usually a hyperbolic tangent activation function. </td></tr>
    <tr><td class="paramname">state_act</td><td>The activation layer of the state at the read gate. Usually a hyperbolic tangent activation function. </td></tr>
    <tr><td class="paramname">read_act</td><td>The activation layer of the read filter. Usually a sigmoid activation function. </td></tr>
    <tr><td class="paramname">output_seq_size_func</td><td>A function parameterized by the input sequence length that determines the output sequence delay and length. The output of the function is a pair of unsigned integers where the first element is the sequence length and the second element is the sequence delay. </td></tr>
    <tr><td class="paramname">reversed</td><td>Whether the network is to reverse its inputs along the time-step rank. </td></tr>
    <tr><td class="paramname">foremost</td><td>Whether the network is to function as a foremost network. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a84a6425deae97b7a267628eb4c4dd251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a6425deae97b7a267628eb4c4dd251">&#9670;&nbsp;</a></span>backpropagate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , std::size_t Rank, bool MulInt = false, bool Stateful = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Root::Data <a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html">cattle::LSTMNeuralNetwork</a>&lt; Scalar, Rank, MulInt, Stateful &gt;::backpropagate </td>
          <td>(</td>
          <td class="paramtype">typename Root::Data&#160;</td>
          <td class="paramname"><em>out_grad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>It back-propagates the derivative of the loss function w.r.t. </p>
<p>the output of the network through its layers updating the gradients on their parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_grad</td><td>The derivative of the loss function w.r.t. the output of the network. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The derivative of the loss function w.r.t. the input of the network or a null tensor if the network is a foremost network. </dd></dl>

<p>Implements <a class="el" href="classcattle_1_1_neural_network.html#a550bd7dea6ddac56160b5cafd54e8962">cattle::NeuralNetwork&lt; Scalar, Rank, true &gt;</a>.</p>

</div>
</div>
<a id="acfe39bea97e1f01279024a8d2a2adbba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe39bea97e1f01279024a8d2a2adbba">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , std::size_t Rank, bool MulInt = false, bool Stateful = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcattle_1_1_neural_network.html">Root</a>* <a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html">cattle::LSTMNeuralNetwork</a>&lt; Scalar, Rank, MulInt, Stateful &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A constant method implementing the clone pattern. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a copy of the instance. The instance does not take ownership of the returned pointer (i.e. the caller is responsible for deleting it). </dd></dl>

<p>Implements <a class="el" href="classcattle_1_1_neural_network.html#a2abd58d4e18caa4ae95563da19c8338b">cattle::NeuralNetwork&lt; Scalar, Rank, true &gt;</a>.</p>

</div>
</div>
<a id="a515956ee97a9f94a2a9001f5ae4bedbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515956ee97a9f94a2a9001f5ae4bedbf">&#9670;&nbsp;</a></span>get_input_dims()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , std::size_t Rank, bool MulInt = false, bool Stateful = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcattle_1_1_dimensions.html">Root::Dims</a>&amp; <a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html">cattle::LSTMNeuralNetwork</a>&lt; Scalar, Rank, MulInt, Stateful &gt;::get_input_dims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the member variable denoting the dimensions of the tensors accepted by the network as its input along (except for the first rank which denotes the variable sample size and in case of sequential networks the second rank which denotes the variable time steps). </dd></dl>

<p>Implements <a class="el" href="classcattle_1_1_neural_network.html#acbea7d3cad12acbd2728e092acba4a25">cattle::NeuralNetwork&lt; Scalar, Rank, true &gt;</a>.</p>

</div>
</div>
<a id="a7de6fa957b2a3fb27771f7e2ef8da72c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7de6fa957b2a3fb27771f7e2ef8da72c">&#9670;&nbsp;</a></span>get_layers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , std::size_t Rank, bool MulInt = false, bool Stateful = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;const <a class="el" href="classcattle_1_1_layer.html">Layer</a>&lt;Scalar,Rank&gt;*&gt; <a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html">cattle::LSTMNeuralNetwork</a>&lt; Scalar, Rank, MulInt, Stateful &gt;::get_layers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A vector of pointers to constant layers constituting the network. The ownership of the layers remains with the network. </dd></dl>

<p>Implements <a class="el" href="classcattle_1_1_neural_network.html#a9e116cf4abef2248b212ef21d58fa4e8">cattle::NeuralNetwork&lt; Scalar, Rank, true &gt;</a>.</p>

</div>
</div>
<a id="a24d781209f6bee0f3c837e625bbf5ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d781209f6bee0f3c837e625bbf5ea7">&#9670;&nbsp;</a></span>get_layers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , std::size_t Rank, bool MulInt = false, bool Stateful = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classcattle_1_1_layer.html">Layer</a>&lt;Scalar,Rank&gt;*&gt; <a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html">cattle::LSTMNeuralNetwork</a>&lt; Scalar, Rank, MulInt, Stateful &gt;::get_layers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A vector of pointers to the layers of the network. The ownership of the layers remains with the network. </dd></dl>

<p>Implements <a class="el" href="classcattle_1_1_neural_network.html#a297039d2fff23643c9b73da7b4bb686c">cattle::NeuralNetwork&lt; Scalar, Rank, true &gt;</a>.</p>

</div>
</div>
<a id="ae10aa3773f5b55532301a6301d9d2cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae10aa3773f5b55532301a6301d9d2cad">&#9670;&nbsp;</a></span>get_output_dims()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , std::size_t Rank, bool MulInt = false, bool Stateful = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcattle_1_1_dimensions.html">Root::Dims</a>&amp; <a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html">cattle::LSTMNeuralNetwork</a>&lt; Scalar, Rank, MulInt, Stateful &gt;::get_output_dims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the member variable denoting the dimensions of the tensors output by the network (except for the first rank which denotes the variable sample size and in case of sequential networks the second rank which denotes the variable time steps). </dd></dl>

<p>Implements <a class="el" href="classcattle_1_1_neural_network.html#abae4c549cee2b29c2b6e072ce0314303">cattle::NeuralNetwork&lt; Scalar, Rank, true &gt;</a>.</p>

</div>
</div>
<a id="a746769e064f987a44c14c555123a9f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a746769e064f987a44c14c555123a9f6a">&#9670;&nbsp;</a></span>is_foremost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , std::size_t Rank, bool MulInt = false, bool Stateful = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html">cattle::LSTMNeuralNetwork</a>&lt; Scalar, Rank, MulInt, Stateful &gt;::is_foremost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Whether the instance is a foremost network. If the instance is not a stand-alone network and it is not the first module of a complex network, it is not a foremost network. Foremost networks do not need to back-propagate the gradients all the way given that no other network is expected to depend on them. </dd></dl>

<p>Implements <a class="el" href="classcattle_1_1_neural_network.html#a5dadb8900281afff9167f02b2d75c86a">cattle::NeuralNetwork&lt; Scalar, Rank, true &gt;</a>.</p>

</div>
</div>
<a id="a83421c050b636f88c130cf98cb90f2e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83421c050b636f88c130cf98cb90f2e1">&#9670;&nbsp;</a></span>is_reversed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , std::size_t Rank, bool MulInt = false, bool Stateful = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html">cattle::LSTMNeuralNetwork</a>&lt; Scalar, Rank, MulInt, Stateful &gt;::is_reversed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Whether the direction along the time-step rank in which the network processes its inputs is reversed. </dd></dl>

<p>Reimplemented from <a class="el" href="classcattle_1_1_unidirectional_neural_network.html#ad9b1b8d8d899cd39db49ce9782e81401">cattle::UnidirectionalNeuralNetwork&lt; Scalar, Rank &gt;</a>.</p>

</div>
</div>
<a id="a06041a938c2b82c3cbbee3545e7f904f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06041a938c2b82c3cbbee3545e7f904f">&#9670;&nbsp;</a></span>propagate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , std::size_t Rank, bool MulInt = false, bool Stateful = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Root::Data <a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html">cattle::LSTMNeuralNetwork</a>&lt; Scalar, Rank, MulInt, Stateful &gt;::propagate </td>
          <td>(</td>
          <td class="paramtype">typename Root::Data&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>training</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>It propagates the input tensor through the network and outputs its prediction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input tensor to propagate through. </td></tr>
    <tr><td class="paramname">training</td><td>Whether the input is to be propagated in training mode or not. Propagating the input in training mode may be more time and memory consuming, but is a prerequisite of back-propagation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output tensor of the network in response to the input. </dd></dl>

<p>Implements <a class="el" href="classcattle_1_1_neural_network.html#a6ade9cd95110766ff25e7b157c9fddcf">cattle::NeuralNetwork&lt; Scalar, Rank, true &gt;</a>.</p>

</div>
</div>
<a id="a392e844c1364349e02be4b0ff8d20b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a392e844c1364349e02be4b0ff8d20b02">&#9670;&nbsp;</a></span>set_foremost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , std::size_t Rank, bool MulInt = false, bool Stateful = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html">cattle::LSTMNeuralNetwork</a>&lt; Scalar, Rank, MulInt, Stateful &gt;::set_foremost </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>foremost</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the foremost status of the network. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">foremost</td><td>Whether the network is to function as a foremost network. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classcattle_1_1_neural_network.html#ae417618e6c761cf7630f24dff2d3568a">cattle::NeuralNetwork&lt; Scalar, Rank, true &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/Viktor/git/C-ATTL3/C-ATTL3/neural_network/<a class="el" href="_l_s_t_m_neural_network_8hpp_source.html">LSTMNeuralNetwork.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
