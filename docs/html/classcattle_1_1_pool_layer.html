<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C-ATTL3: cattle::PoolLayer&lt; Scalar, Rank &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C-ATTL3
   &#160;<span id="projectnumber">0.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecattle.html">cattle</a></li><li class="navelem"><a class="el" href="classcattle_1_1_pool_layer.html">PoolLayer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classcattle_1_1_pool_layer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cattle::PoolLayer&lt; Scalar, Rank &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>An abstract base class template representing a pooling layer.  
 <a href="classcattle_1_1_pool_layer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_pool_layer_8hpp_source.html">PoolLayer.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cattle::PoolLayer&lt; Scalar, Rank &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcattle_1_1_pool_layer.png" usemap="#cattle::PoolLayer_3C_20Scalar_2C_20Rank_20_3E_map" alt=""/>
  <map id="cattle::PoolLayer_3C_20Scalar_2C_20Rank_20_3E_map" name="cattle::PoolLayer_3C_20Scalar_2C_20Rank_20_3E_map">
<area href="classcattle_1_1_layer.html" title="An abstract class template representing layers in a neural network. " alt="cattle::Layer&lt; Scalar, Rank &gt;" shape="rect" coords="685,0,949,24"/>
<area href="classcattle_1_1_max_pool_layer_base.html" title="An abstract class template representing a pooling layer that reduces patches of the input by taking t..." alt="cattle::MaxPoolLayerBase&lt; Scalar, Rank &gt;" shape="rect" coords="0,112,264,136"/>
<area href="classcattle_1_1_mean_pool_layer_base.html" title="An abstract class template representing a pooling layer that reduces patches of the input by taking t..." alt="cattle::MeanPoolLayerBase&lt; Scalar, Rank &gt;" shape="rect" coords="274,112,538,136"/>
<area href="classcattle_1_1_max_pool_layer_base.html" alt="cattle::MaxPoolLayerBase&lt; Scalar, 1 &gt;" shape="rect" coords="548,112,812,136"/>
<area href="classcattle_1_1_max_pool_layer_base.html" alt="cattle::MaxPoolLayerBase&lt; Scalar, 2 &gt;" shape="rect" coords="822,112,1086,136"/>
<area href="classcattle_1_1_mean_pool_layer_base.html" alt="cattle::MeanPoolLayerBase&lt; Scalar, 1 &gt;" shape="rect" coords="1096,112,1360,136"/>
<area href="classcattle_1_1_mean_pool_layer_base.html" alt="cattle::MeanPoolLayerBase&lt; Scalar, 2 &gt;" shape="rect" coords="1370,112,1634,136"/>
<area href="classcattle_1_1_max_pool_layer.html" title="A class template representing a 2D max pooling layer operating on rank-3 data. " alt="cattle::MaxPoolLayer&lt; Scalar, Rank &gt;" shape="rect" coords="0,168,264,192"/>
<area href="classcattle_1_1_mean_pool_layer.html" title="A class template representing a 2D mean pooling layer operating on rank-3 data. " alt="cattle::MeanPoolLayer&lt; Scalar, Rank &gt;" shape="rect" coords="274,168,538,192"/>
<area href="classcattle_1_1_max_pool_layer_3_01_scalar_00_011_01_4.html" title="A class template representing a 1D max pooling layer. " alt="cattle::MaxPoolLayer&lt; Scalar, 1 &gt;" shape="rect" coords="548,168,812,192"/>
<area href="classcattle_1_1_max_pool_layer_3_01_scalar_00_012_01_4.html" title="A class template representing a 2D max pooling layer operating on rank-2 data. " alt="cattle::MaxPoolLayer&lt; Scalar, 2 &gt;" shape="rect" coords="822,168,1086,192"/>
<area href="classcattle_1_1_mean_pool_layer_3_01_scalar_00_011_01_4.html" title="A class template representing a 1D mean pooling layer. " alt="cattle::MeanPoolLayer&lt; Scalar, 1 &gt;" shape="rect" coords="1096,168,1360,192"/>
<area href="classcattle_1_1_mean_pool_layer_3_01_scalar_00_012_01_4.html" title="A class template representing a 2D mean pooling layer operating on rank-2 data. " alt="cattle::MeanPoolLayer&lt; Scalar, 2 &gt;" shape="rect" coords="1370,168,1634,192"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a40d43922450a2d28e36057256905403e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcattle_1_1_layer.html">Base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_pool_layer.html#a40d43922450a2d28e36057256905403e">clone</a> () const =0</td></tr>
<tr class="memdesc:a40d43922450a2d28e36057256905403e"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns a clone of the layer instance.  <a href="#a40d43922450a2d28e36057256905403e">More...</a><br /></td></tr>
<tr class="separator:a40d43922450a2d28e36057256905403e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2197c18cdbc8c8e80bc059d8f36a4d5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcattle_1_1_layer.html">Base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_pool_layer.html#a2197c18cdbc8c8e80bc059d8f36a4d5c">clone_with_shared_params</a> ()</td></tr>
<tr class="memdesc:a2197c18cdbc8c8e80bc059d8f36a4d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns a clone of the layer instance using a reference to the original's parameters.  <a href="#a2197c18cdbc8c8e80bc059d8f36a4d5c">More...</a><br /></td></tr>
<tr class="separator:a2197c18cdbc8c8e80bc059d8f36a4d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5920113d2477183eb7f64a5e92fa2ab6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcattle_1_1_layer.html">Base</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_pool_layer.html#a5920113d2477183eb7f64a5e92fa2ab6">get_params_owner</a> () const</td></tr>
<tr class="memdesc:a5920113d2477183eb7f64a5e92fa2ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns a reference to the layer owning the parameters used.  <a href="#a5920113d2477183eb7f64a5e92fa2ab6">More...</a><br /></td></tr>
<tr class="separator:a5920113d2477183eb7f64a5e92fa2ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39d93f2aeb8c2adf888d1dbe6bacc4d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcattle_1_1_dimensions.html">Base::Dims</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_pool_layer.html#aa39d93f2aeb8c2adf888d1dbe6bacc4d">get_input_dims</a> () const</td></tr>
<tr class="memdesc:aa39d93f2aeb8c2adf888d1dbe6bacc4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple constant getter method for the input dimensionality of the layer.  <a href="#aa39d93f2aeb8c2adf888d1dbe6bacc4d">More...</a><br /></td></tr>
<tr class="separator:aa39d93f2aeb8c2adf888d1dbe6bacc4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f512d4b0a4df20ad1ff86da65e1917"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcattle_1_1_dimensions.html">Base::Dims</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_pool_layer.html#ac9f512d4b0a4df20ad1ff86da65e1917">get_output_dims</a> () const</td></tr>
<tr class="memdesc:ac9f512d4b0a4df20ad1ff86da65e1917"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple constant getter method for the output dimensionality of the layer.  <a href="#ac9f512d4b0a4df20ad1ff86da65e1917">More...</a><br /></td></tr>
<tr class="separator:ac9f512d4b0a4df20ad1ff86da65e1917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f08f1fb9ee99afb1a899a38ff12adbf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_pool_layer.html#a1f08f1fb9ee99afb1a899a38ff12adbf">is_input_layer</a> () const</td></tr>
<tr class="memdesc:a1f08f1fb9ee99afb1a899a38ff12adbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant method that returns whether this layer functions as an input layer.  <a href="#a1f08f1fb9ee99afb1a899a38ff12adbf">More...</a><br /></td></tr>
<tr class="separator:a1f08f1fb9ee99afb1a899a38ff12adbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584687e28d220062f36ec67d0cf90054"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_pool_layer.html#a584687e28d220062f36ec67d0cf90054">set_input_layer</a> (bool input_layer)</td></tr>
<tr class="memdesc:a584687e28d220062f36ec67d0cf90054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this instance's input layer status to the given value.  <a href="#a584687e28d220062f36ec67d0cf90054">More...</a><br /></td></tr>
<tr class="separator:a584687e28d220062f36ec67d0cf90054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a57d29cefeac14d42fcf5049921df91"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const Parameters&lt; Scalar &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_pool_layer.html#a4a57d29cefeac14d42fcf5049921df91">get_params</a> () const</td></tr>
<tr class="memdesc:a4a57d29cefeac14d42fcf5049921df91"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns a vector of constant non-owning pointers to the parameters of the layer.  <a href="#a4a57d29cefeac14d42fcf5049921df91">More...</a><br /></td></tr>
<tr class="separator:a4a57d29cefeac14d42fcf5049921df91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81206a1f6b08fdd52d9d3719bdf18be2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Parameters&lt; Scalar &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_pool_layer.html#a81206a1f6b08fdd52d9d3719bdf18be2">get_params</a> ()</td></tr>
<tr class="memdesc:a81206a1f6b08fdd52d9d3719bdf18be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns a vector of non-owning pointers to the parameters of the layer.  <a href="#a81206a1f6b08fdd52d9d3719bdf18be2">More...</a><br /></td></tr>
<tr class="separator:a81206a1f6b08fdd52d9d3719bdf18be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcattle_1_1_layer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcattle_1_1_layer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcattle_1_1_layer.html">cattle::Layer&lt; Scalar, Rank &gt;</a></td></tr>
<tr class="memitem:ae3d00e9fb6079e4b4990b3a14625a93d inherit pub_methods_classcattle_1_1_layer"><td class="memItemLeft" align="right" valign="top"><a id="ae3d00e9fb6079e4b4990b3a14625a93d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_layer.html#ae3d00e9fb6079e4b4990b3a14625a93d">empty_cache</a> ()=0</td></tr>
<tr class="memdesc:ae3d00e9fb6079e4b4990b3a14625a93d inherit pub_methods_classcattle_1_1_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">It empties the layer's caches such as those required for the derivation of the function represented by the layer. <br /></td></tr>
<tr class="separator:ae3d00e9fb6079e4b4990b3a14625a93d inherit pub_methods_classcattle_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1ea7b25d9f882364b7f2288f02d8da inherit pub_methods_classcattle_1_1_layer"><td class="memItemLeft" align="right" valign="top">virtual Data&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_layer.html#a6c1ea7b25d9f882364b7f2288f02d8da">pass_forward</a> (Data in, bool training)=0</td></tr>
<tr class="memdesc:a6c1ea7b25d9f882364b7f2288f02d8da inherit pub_methods_classcattle_1_1_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">It has the function represented by the layer applied to the input tensor.  <a href="classcattle_1_1_layer.html#a6c1ea7b25d9f882364b7f2288f02d8da">More...</a><br /></td></tr>
<tr class="separator:a6c1ea7b25d9f882364b7f2288f02d8da inherit pub_methods_classcattle_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb51862ef9b87632b5abb8e3ab36dd9 inherit pub_methods_classcattle_1_1_layer"><td class="memItemLeft" align="right" valign="top">virtual Data&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_layer.html#a7cb51862ef9b87632b5abb8e3ab36dd9">pass_back</a> (Data out_grad)=0</td></tr>
<tr class="memdesc:a7cb51862ef9b87632b5abb8e3ab36dd9 inherit pub_methods_classcattle_1_1_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">It back-propagates the derivative of the error function w.r.t.  <a href="classcattle_1_1_layer.html#a7cb51862ef9b87632b5abb8e3ab36dd9">More...</a><br /></td></tr>
<tr class="separator:a7cb51862ef9b87632b5abb8e3ab36dd9 inherit pub_methods_classcattle_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92d606818b5a240d0ce898e35afe63d inherit pub_methods_classcattle_1_1_layer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_layer.html#ac92d606818b5a240d0ce898e35afe63d">is_shared_params_clone</a> () const</td></tr>
<tr class="memdesc:ac92d606818b5a240d0ce898e35afe63d inherit pub_methods_classcattle_1_1_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">It determines whether the layer instance is a clone using the shared parameters of another instance.  <a href="classcattle_1_1_layer.html#ac92d606818b5a240d0ce898e35afe63d">More...</a><br /></td></tr>
<tr class="separator:ac92d606818b5a240d0ce898e35afe63d inherit pub_methods_classcattle_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba02f76506a7f8a72f44be78693209e inherit pub_methods_classcattle_1_1_layer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_layer.html#a3ba02f76506a7f8a72f44be78693209e">is_parametric</a> () const</td></tr>
<tr class="memdesc:a3ba02f76506a7f8a72f44be78693209e inherit pub_methods_classcattle_1_1_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">A method that returns whether the layer has parameters.  <a href="classcattle_1_1_layer.html#a3ba02f76506a7f8a72f44be78693209e">More...</a><br /></td></tr>
<tr class="separator:a3ba02f76506a7f8a72f44be78693209e inherit pub_methods_classcattle_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae5c4d2b057b9f7edc6eb3ca4c1b9ade8"><td class="memItemLeft" align="right" valign="top"><a id="ae5c4d2b057b9f7edc6eb3ca4c1b9ade8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_pool_layer.html#ae5c4d2b057b9f7edc6eb3ca4c1b9ade8">_init_cache</a> ()=0</td></tr>
<tr class="memdesc:ae5c4d2b057b9f7edc6eb3ca4c1b9ade8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the cache required for back-propagation. <br /></td></tr>
<tr class="separator:ae5c4d2b057b9f7edc6eb3ca4c1b9ade8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ba868123db71633f79628f5112fa06"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacecattle.html#a8b9323ad928764340e46f0802bf27fbb">Tensor</a>&lt; Scalar, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_pool_layer.html#af4ba868123db71633f79628f5112fa06">_reduce</a> (const <a class="el" href="namespacecattle.html#a8b9323ad928764340e46f0802bf27fbb">Tensor</a>&lt; Scalar, 4 &gt; &amp;patch, std::size_t patch_ind)=0</td></tr>
<tr class="memdesc:af4ba868123db71633f79628f5112fa06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces the input tensor patch along the specified ranks.  <a href="#af4ba868123db71633f79628f5112fa06">More...</a><br /></td></tr>
<tr class="separator:af4ba868123db71633f79628f5112fa06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b451faf349bb303657bc6c6d60abf8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacecattle.html#a8b9323ad928764340e46f0802bf27fbb">Tensor</a>&lt; Scalar, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_pool_layer.html#a88b451faf349bb303657bc6c6d60abf8">_d_reduce</a> (const <a class="el" href="namespacecattle.html#a8b9323ad928764340e46f0802bf27fbb">Tensor</a>&lt; Scalar, 4 &gt; &amp;grad, std::size_t patch_ind)=0</td></tr>
<tr class="memdesc:a88b451faf349bb303657bc6c6d60abf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Differentiates the reduction function and returns the derivative of the loss function w.r.t.  <a href="#a88b451faf349bb303657bc6c6d60abf8">More...</a><br /></td></tr>
<tr class="separator:a88b451faf349bb303657bc6c6d60abf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Scalar, std::size_t Rank&gt;<br />
class cattle::PoolLayer&lt; Scalar, Rank &gt;</h3>

<p>An abstract base class template representing a pooling layer. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a88b451faf349bb303657bc6c6d60abf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88b451faf349bb303657bc6c6d60abf8">&#9670;&nbsp;</a></span>_d_reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , std::size_t Rank&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacecattle.html#a8b9323ad928764340e46f0802bf27fbb">Tensor</a>&lt;Scalar,4&gt; <a class="el" href="classcattle_1_1_pool_layer.html">cattle::PoolLayer</a>&lt; Scalar, Rank &gt;::_d_reduce </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecattle.html#a8b9323ad928764340e46f0802bf27fbb">Tensor</a>&lt; Scalar, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>grad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>patch_ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Differentiates the reduction function and returns the derivative of the loss function w.r.t. </p>
<p>the non-reduced patch.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grad</td><td>The derivative of the loss function w.r.t. the reduced patch. </td></tr>
    <tr><td class="paramname">patch_ind</td><td>The index of the patch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The derivative of the loss function w.r.t. the non-reduced patch. </dd></dl>

<p>Implemented in <a class="el" href="classcattle_1_1_max_pool_layer_base.html#af34fe1a2706503a74ef87f2ed8364a6f">cattle::MaxPoolLayerBase&lt; Scalar, Rank &gt;</a>, <a class="el" href="classcattle_1_1_max_pool_layer_base.html#af34fe1a2706503a74ef87f2ed8364a6f">cattle::MaxPoolLayerBase&lt; Scalar, 1 &gt;</a>, <a class="el" href="classcattle_1_1_max_pool_layer_base.html#af34fe1a2706503a74ef87f2ed8364a6f">cattle::MaxPoolLayerBase&lt; Scalar, 2 &gt;</a>, <a class="el" href="classcattle_1_1_mean_pool_layer_base.html#a11d69acda36367bdb1187f7485b90f9e">cattle::MeanPoolLayerBase&lt; Scalar, Rank &gt;</a>, <a class="el" href="classcattle_1_1_mean_pool_layer_base.html#a11d69acda36367bdb1187f7485b90f9e">cattle::MeanPoolLayerBase&lt; Scalar, 1 &gt;</a>, and <a class="el" href="classcattle_1_1_mean_pool_layer_base.html#a11d69acda36367bdb1187f7485b90f9e">cattle::MeanPoolLayerBase&lt; Scalar, 2 &gt;</a>.</p>

</div>
</div>
<a id="af4ba868123db71633f79628f5112fa06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ba868123db71633f79628f5112fa06">&#9670;&nbsp;</a></span>_reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , std::size_t Rank&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacecattle.html#a8b9323ad928764340e46f0802bf27fbb">Tensor</a>&lt;Scalar,4&gt; <a class="el" href="classcattle_1_1_pool_layer.html">cattle::PoolLayer</a>&lt; Scalar, Rank &gt;::_reduce </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecattle.html#a8b9323ad928764340e46f0802bf27fbb">Tensor</a>&lt; Scalar, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>patch_ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduces the input tensor patch along the specified ranks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patch</td><td>A tensor representing a spatial patch of the input tensor. </td></tr>
    <tr><td class="paramname">patch_ind</td><td>The index of the patch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reduced tensor. </dd></dl>

<p>Implemented in <a class="el" href="classcattle_1_1_max_pool_layer_base.html#adba251e3a789c00b852d896e3742f3b4">cattle::MaxPoolLayerBase&lt; Scalar, Rank &gt;</a>, <a class="el" href="classcattle_1_1_max_pool_layer_base.html#adba251e3a789c00b852d896e3742f3b4">cattle::MaxPoolLayerBase&lt; Scalar, 1 &gt;</a>, <a class="el" href="classcattle_1_1_max_pool_layer_base.html#adba251e3a789c00b852d896e3742f3b4">cattle::MaxPoolLayerBase&lt; Scalar, 2 &gt;</a>, <a class="el" href="classcattle_1_1_mean_pool_layer_base.html#a0b9a18aa55e2c5e3653f85950980ab74">cattle::MeanPoolLayerBase&lt; Scalar, Rank &gt;</a>, <a class="el" href="classcattle_1_1_mean_pool_layer_base.html#a0b9a18aa55e2c5e3653f85950980ab74">cattle::MeanPoolLayerBase&lt; Scalar, 1 &gt;</a>, and <a class="el" href="classcattle_1_1_mean_pool_layer_base.html#a0b9a18aa55e2c5e3653f85950980ab74">cattle::MeanPoolLayerBase&lt; Scalar, 2 &gt;</a>.</p>

</div>
</div>
<a id="a40d43922450a2d28e36057256905403e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40d43922450a2d28e36057256905403e">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , std::size_t Rank&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcattle_1_1_layer.html">Base</a>* <a class="el" href="classcattle_1_1_pool_layer.html">cattle::PoolLayer</a>&lt; Scalar, Rank &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>It returns a clone of the layer instance. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a copy of the instance. The instance does not take ownership of the returned pointer (i.e. the caller is responsible for deleting it). </dd></dl>

<p>Implements <a class="el" href="classcattle_1_1_layer.html#a46db46c62f3d46c6bbef5a482d7fcb00">cattle::Layer&lt; Scalar, Rank &gt;</a>.</p>

<p>Implemented in <a class="el" href="classcattle_1_1_max_pool_layer_3_01_scalar_00_011_01_4.html#a3190763e39f851cf28606dc1b7906f4a">cattle::MaxPoolLayer&lt; Scalar, 1 &gt;</a>, <a class="el" href="classcattle_1_1_mean_pool_layer_3_01_scalar_00_011_01_4.html#acee10ea9184f727d8734038b2f390bee">cattle::MeanPoolLayer&lt; Scalar, 1 &gt;</a>, <a class="el" href="classcattle_1_1_max_pool_layer_3_01_scalar_00_012_01_4.html#abf3096d94719bacc657cca0fcad1afb4">cattle::MaxPoolLayer&lt; Scalar, 2 &gt;</a>, <a class="el" href="classcattle_1_1_mean_pool_layer_3_01_scalar_00_012_01_4.html#a624e7117839125b1c67c1178e381064c">cattle::MeanPoolLayer&lt; Scalar, 2 &gt;</a>, <a class="el" href="classcattle_1_1_max_pool_layer.html#a26a24d870ec2b776bc5c229ba01448a7">cattle::MaxPoolLayer&lt; Scalar, Rank &gt;</a>, and <a class="el" href="classcattle_1_1_mean_pool_layer.html#a78fe029b0af419a4a04fd0526e444445">cattle::MeanPoolLayer&lt; Scalar, Rank &gt;</a>.</p>

</div>
</div>
<a id="a2197c18cdbc8c8e80bc059d8f36a4d5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2197c18cdbc8c8e80bc059d8f36a4d5c">&#9670;&nbsp;</a></span>clone_with_shared_params()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , std::size_t Rank&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcattle_1_1_layer.html">Base</a>* <a class="el" href="classcattle_1_1_pool_layer.html">cattle::PoolLayer</a>&lt; Scalar, Rank &gt;::clone_with_shared_params </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>It returns a clone of the layer instance using a reference to the original's parameters. </p>
<p>Non-parametric layers do not need to support parameter sharing and thus are just expected to return a normal clone.</p>
<dl class="section return"><dt>Returns</dt><dd>A clone of the original layer instance sharing the same parameters with the original. </dd></dl>

<p>Implements <a class="el" href="classcattle_1_1_layer.html#a074a197df04250449a059d97a4e6e120">cattle::Layer&lt; Scalar, Rank &gt;</a>.</p>

</div>
</div>
<a id="aa39d93f2aeb8c2adf888d1dbe6bacc4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa39d93f2aeb8c2adf888d1dbe6bacc4d">&#9670;&nbsp;</a></span>get_input_dims()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , std::size_t Rank&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcattle_1_1_dimensions.html">Base::Dims</a>&amp; <a class="el" href="classcattle_1_1_pool_layer.html">cattle::PoolLayer</a>&lt; Scalar, Rank &gt;::get_input_dims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A simple constant getter method for the input dimensionality of the layer. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the member variable denoting the dimensions of the tensors accepted by the layer as its input (except for the first rank which denotes the variable sample size). </dd></dl>

<p>Implements <a class="el" href="classcattle_1_1_layer.html#a450d75b5f9e084552819ad8fdcf2ad59">cattle::Layer&lt; Scalar, Rank &gt;</a>.</p>

</div>
</div>
<a id="ac9f512d4b0a4df20ad1ff86da65e1917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f512d4b0a4df20ad1ff86da65e1917">&#9670;&nbsp;</a></span>get_output_dims()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , std::size_t Rank&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcattle_1_1_dimensions.html">Base::Dims</a>&amp; <a class="el" href="classcattle_1_1_pool_layer.html">cattle::PoolLayer</a>&lt; Scalar, Rank &gt;::get_output_dims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A simple constant getter method for the output dimensionality of the layer. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the member variable denoting the dimensions of the tensors output by the layer along all ranks except the first one. </dd></dl>

<p>Implements <a class="el" href="classcattle_1_1_layer.html#af29a87e0166c1dedc60af30ee392d099">cattle::Layer&lt; Scalar, Rank &gt;</a>.</p>

</div>
</div>
<a id="a4a57d29cefeac14d42fcf5049921df91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a57d29cefeac14d42fcf5049921df91">&#9670;&nbsp;</a></span>get_params() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , std::size_t Rank&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;const Parameters&lt;Scalar&gt;*&gt; <a class="el" href="classcattle_1_1_pool_layer.html">cattle::PoolLayer</a>&lt; Scalar, Rank &gt;::get_params </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>It returns a vector of constant non-owning pointers to the parameters of the layer. </p>
<dl class="section return"><dt>Returns</dt><dd>A vector of constant pointers to the parameters of the layer. </dd></dl>

<p>Implements <a class="el" href="classcattle_1_1_layer.html#a0ec2fb727209b884263e29759fdf3b39">cattle::Layer&lt; Scalar, Rank &gt;</a>.</p>

</div>
</div>
<a id="a81206a1f6b08fdd52d9d3719bdf18be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81206a1f6b08fdd52d9d3719bdf18be2">&#9670;&nbsp;</a></span>get_params() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , std::size_t Rank&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Parameters&lt;Scalar&gt;*&gt; <a class="el" href="classcattle_1_1_pool_layer.html">cattle::PoolLayer</a>&lt; Scalar, Rank &gt;::get_params </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>It returns a vector of non-owning pointers to the parameters of the layer. </p>
<dl class="section return"><dt>Returns</dt><dd>A vector of pointers to the parameters of the layer. </dd></dl>

<p>Implements <a class="el" href="classcattle_1_1_layer.html#ad2ec670602524164665de1d0e6eb0b19">cattle::Layer&lt; Scalar, Rank &gt;</a>.</p>

</div>
</div>
<a id="a5920113d2477183eb7f64a5e92fa2ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5920113d2477183eb7f64a5e92fa2ab6">&#9670;&nbsp;</a></span>get_params_owner()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , std::size_t Rank&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcattle_1_1_layer.html">Base</a>&amp; <a class="el" href="classcattle_1_1_pool_layer.html">cattle::PoolLayer</a>&lt; Scalar, Rank &gt;::get_params_owner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>It returns a reference to the layer owning the parameters used. </p>
<p>If this owner goes out of scope (in case this one is a clone with shared parameters), the behaviour of the clone is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the layer owning the parameters. If this layer is not using shared parameters, it returns a reference to itself. </dd></dl>

<p>Implements <a class="el" href="classcattle_1_1_layer.html#a683f9b67748863329938da07e86ecd8c">cattle::Layer&lt; Scalar, Rank &gt;</a>.</p>

</div>
</div>
<a id="a1f08f1fb9ee99afb1a899a38ff12adbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f08f1fb9ee99afb1a899a38ff12adbf">&#9670;&nbsp;</a></span>is_input_layer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , std::size_t Rank&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcattle_1_1_pool_layer.html">cattle::PoolLayer</a>&lt; Scalar, Rank &gt;::is_input_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A constant method that returns whether this layer functions as an input layer. </p>
<p>An input layer does not need to propagate the gradients all the way during the backward pass as it is assumed that no other layer needs them derive the gradient on its parameters. It is therefore possible for an input layer to simply return a null tensor as the output of its backward pass.</p>
<dl class="section return"><dt>Returns</dt><dd>Whether this layer is the input layer of the neural network that contains it. </dd></dl>

<p>Implements <a class="el" href="classcattle_1_1_layer.html#af208065ae34cbebcdc932c84383ea159">cattle::Layer&lt; Scalar, Rank &gt;</a>.</p>

</div>
</div>
<a id="a584687e28d220062f36ec67d0cf90054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a584687e28d220062f36ec67d0cf90054">&#9670;&nbsp;</a></span>set_input_layer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , std::size_t Rank&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcattle_1_1_pool_layer.html">cattle::PoolLayer</a>&lt; Scalar, Rank &gt;::set_input_layer </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>input_layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this instance's input layer status to the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_layer</td><td>Whether this layer is to be an input layer or not. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classcattle_1_1_layer.html#a9557e077d940b2ff0c280e9a78c4b52e">cattle::Layer&lt; Scalar, Rank &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/viktorcsomor/git/C-ATTL3/C-ATTL3/layer/<a class="el" href="_pool_layer_8hpp_source.html">PoolLayer.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
