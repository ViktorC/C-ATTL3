<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C-ATTL3: cattle::NeuralNetwork&lt; Scalar, Rank, Sequential &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C-ATTL3
   &#160;<span id="projectnumber">0.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecattle.html">cattle</a></li><li class="navelem"><a class="el" href="classcattle_1_1_neural_network.html">NeuralNetwork</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="classcattle_1_1_neural_network-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cattle::NeuralNetwork&lt; Scalar, Rank, Sequential &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>An abstract neural network class template.  
 <a href="classcattle_1_1_neural_network.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_neural_network_8hpp_source.html">NeuralNetwork.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cattle::NeuralNetwork&lt; Scalar, Rank, Sequential &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcattle_1_1_neural_network.png" usemap="#cattle::NeuralNetwork_3C_20Scalar_2C_20Rank_2C_20Sequential_20_3E_map" alt=""/>
  <map id="cattle::NeuralNetwork_3C_20Scalar_2C_20Rank_2C_20Sequential_20_3E_map" name="cattle::NeuralNetwork_3C_20Scalar_2C_20Rank_2C_20Sequential_20_3E_map">
<area href="classcattle_1_1_composite_neural_network.html" title="A class template for composite neural networks consisting of one or more neural network modules..." alt="cattle::CompositeNeuralNetwork&lt; Scalar, Rank, Sequential, Module &gt;" shape="rect" coords="0,56,613,80"/>
<area href="classcattle_1_1_composite_neural_network.html" alt="cattle::CompositeNeuralNetwork&lt; Scalar, Rank, false, NeuralNetwork&lt; Scalar, Rank, false &gt; &gt;" shape="rect" coords="623,56,1236,80"/>
<area href="classcattle_1_1_composite_neural_network.html" alt="cattle::CompositeNeuralNetwork&lt; Scalar, Rank, Sequential, NeuralNetwork&lt; Scalar, Rank, Sequential &gt; &gt;" shape="rect" coords="1869,56,2482,80"/>
<area href="classcattle_1_1_composite_neural_network.html" alt="cattle::CompositeNeuralNetwork&lt; Scalar, Rank, true, NeuralNetwork&lt; Scalar, Rank, false &gt; &gt;" shape="rect" coords="2803,56,3416,80"/>
<area href="classcattle_1_1_composite_neural_network.html" alt="cattle::CompositeNeuralNetwork&lt; Scalar, Rank, true, UnidirectionalNeuralNetwork&lt; Scalar, Rank &gt; &gt;" shape="rect" coords="3738,56,4351,80"/>
<area href="classcattle_1_1_dense_neural_network.html" title="A class template for DenseNet architectures. " alt="cattle::DenseNeuralNetwork&lt; Scalar, Rank, ConcatType &gt;" shape="rect" coords="0,112,613,136"/>
<area href="classcattle_1_1_parallel_neural_network.html" title="A class template for a parallel neural network that consists of one or more lanes of non-sequential n..." alt="cattle::ParallelNeuralNetwork&lt; Scalar, Rank, MergeType &gt;" shape="rect" coords="623,112,1236,136"/>
<area href="classcattle_1_1_residual_neural_network.html" title="A class template for ResNets. " alt="cattle::ResidualNeuralNetwork&lt; Scalar, Rank &gt;" shape="rect" coords="1246,112,1859,136"/>
<area href="classcattle_1_1_stacked_neural_network.html" title="A class template for a composite neural network that consists of a set of serially stacked neural net..." alt="cattle::StackedNeuralNetwork&lt; Scalar, Rank, Sequential &gt;" shape="rect" coords="1869,112,2482,136"/>
<area href="classcattle_1_1_sequential_neural_network.html" title="A class template for a wrapper neural network that enables the use of non-sequential networks on sequ..." alt="cattle::SequentialNeuralNetwork&lt; Scalar, Rank &gt;" shape="rect" coords="2492,112,3105,136"/>
<area href="classcattle_1_1_temporal_neural_network.html" title="A class template for a wrapper neural network that enables the use of non-sequential networks on sequ..." alt="cattle::TemporalNeuralNetwork&lt; Scalar, Rank &gt;" shape="rect" coords="3115,112,3728,136"/>
<area href="classcattle_1_1_bidirectional_neural_network.html" title="A class template for a bidirectional neural network that takes a unidirectional recurrent network..." alt="cattle::BidirectionalNeuralNetwork&lt; Scalar, Rank, MergeType &gt;" shape="rect" coords="3738,112,4351,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2abd58d4e18caa4ae95563da19c8338b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcattle_1_1_neural_network.html">NeuralNetwork</a>&lt; Scalar, Rank, Sequential &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_neural_network.html#a2abd58d4e18caa4ae95563da19c8338b">clone</a> () const =0</td></tr>
<tr class="memdesc:a2abd58d4e18caa4ae95563da19c8338b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant method implementing the clone pattern.  <a href="#a2abd58d4e18caa4ae95563da19c8338b">More...</a><br /></td></tr>
<tr class="separator:a2abd58d4e18caa4ae95563da19c8338b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbea7d3cad12acbd2728e092acba4a25"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classcattle_1_1_dimensions.html">Dims</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_neural_network.html#acbea7d3cad12acbd2728e092acba4a25">get_input_dims</a> () const =0</td></tr>
<tr class="separator:acbea7d3cad12acbd2728e092acba4a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae4c549cee2b29c2b6e072ce0314303"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classcattle_1_1_dimensions.html">Dims</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_neural_network.html#abae4c549cee2b29c2b6e072ce0314303">get_output_dims</a> () const =0</td></tr>
<tr class="separator:abae4c549cee2b29c2b6e072ce0314303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297039d2fff23643c9b73da7b4bb686c"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classcattle_1_1_layer.html">Layer</a>&lt; Scalar, Rank &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_neural_network.html#a297039d2fff23643c9b73da7b4bb686c">get_layers</a> ()=0</td></tr>
<tr class="separator:a297039d2fff23643c9b73da7b4bb686c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dadb8900281afff9167f02b2d75c86a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_neural_network.html#a5dadb8900281afff9167f02b2d75c86a">is_foremost</a> () const =0</td></tr>
<tr class="separator:a5dadb8900281afff9167f02b2d75c86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a8c8170471486c5f10ba09a5709ad6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_neural_network.html#a94a8c8170471486c5f10ba09a5709ad6">set_frozen</a> (bool frozen)</td></tr>
<tr class="memdesc:a94a8c8170471486c5f10ba09a5709ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the <a class="el" href="classcattle_1_1_layer.html#a2efa46d4b10ec998cb7b09a3c430e025" title="A method for setting whether the parameters of the layer should not be updated during optimization...">Layer::set_frozen(bool)</a> method of all layers of the network with the provided argument.  <a href="#a94a8c8170471486c5f10ba09a5709ad6">More...</a><br /></td></tr>
<tr class="separator:a94a8c8170471486c5f10ba09a5709ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59c0963d75b1f2de4f18a6c8fe85fa8"><td class="memItemLeft" align="right" valign="top"><a id="ae59c0963d75b1f2de4f18a6c8fe85fa8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_neural_network.html#ae59c0963d75b1f2de4f18a6c8fe85fa8">init</a> ()</td></tr>
<tr class="memdesc:ae59c0963d75b1f2de4f18a6c8fe85fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes all layers of the network. <br /></td></tr>
<tr class="separator:ae59c0963d75b1f2de4f18a6c8fe85fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88007e2f8fa2a208de0e51c8ac422cc"><td class="memItemLeft" align="right" valign="top">virtual Data&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_neural_network.html#ac88007e2f8fa2a208de0e51c8ac422cc">infer</a> (Data input)</td></tr>
<tr class="memdesc:ac88007e2f8fa2a208de0e51c8ac422cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">It propagates the input through the neural network and outputs its prediction according to its current parameters.  <a href="#ac88007e2f8fa2a208de0e51c8ac422cc">More...</a><br /></td></tr>
<tr class="separator:ac88007e2f8fa2a208de0e51c8ac422cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad216c4f30172a8924e959d103e38a82c"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_neural_network.html#ad216c4f30172a8924e959d103e38a82c">to_string</a> ()</td></tr>
<tr class="separator:ad216c4f30172a8924e959d103e38a82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae417618e6c761cf7630f24dff2d3568a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_neural_network.html#ae417618e6c761cf7630f24dff2d3568a">set_foremost</a> (bool foremost)=0</td></tr>
<tr class="memdesc:ae417618e6c761cf7630f24dff2d3568a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the foremost status of the network.  <a href="#ae417618e6c761cf7630f24dff2d3568a">More...</a><br /></td></tr>
<tr class="separator:ae417618e6c761cf7630f24dff2d3568a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca6f92bd8f0f284d05ed4fef5af55ca"><td class="memItemLeft" align="right" valign="top"><a id="a9ca6f92bd8f0f284d05ed4fef5af55ca"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_neural_network.html#a9ca6f92bd8f0f284d05ed4fef5af55ca">empty_caches</a> ()=0</td></tr>
<tr class="memdesc:a9ca6f92bd8f0f284d05ed4fef5af55ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empties the caches of every layer of the network. <br /></td></tr>
<tr class="separator:a9ca6f92bd8f0f284d05ed4fef5af55ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ade9cd95110766ff25e7b157c9fddcf"><td class="memItemLeft" align="right" valign="top">virtual Data&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_neural_network.html#a6ade9cd95110766ff25e7b157c9fddcf">propagate</a> (Data input, bool training)=0</td></tr>
<tr class="memdesc:a6ade9cd95110766ff25e7b157c9fddcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">It propagates the input tensor through the network and outputs its prediction.  <a href="#a6ade9cd95110766ff25e7b157c9fddcf">More...</a><br /></td></tr>
<tr class="separator:a6ade9cd95110766ff25e7b157c9fddcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550bd7dea6ddac56160b5cafd54e8962"><td class="memItemLeft" align="right" valign="top">virtual Data&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_neural_network.html#a550bd7dea6ddac56160b5cafd54e8962">backpropagate</a> (Data out_grad)=0</td></tr>
<tr class="memdesc:a550bd7dea6ddac56160b5cafd54e8962"><td class="mdescLeft">&#160;</td><td class="mdescRight">It back-propagates the derivative of the loss function w.r.t.  <a href="#a550bd7dea6ddac56160b5cafd54e8962">More...</a><br /></td></tr>
<tr class="separator:a550bd7dea6ddac56160b5cafd54e8962"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:aeb549ff03b351397f4c7bded24d55e7c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcattle_1_1_layer.html">Layer</a>&lt; Scalar, Rank &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_neural_network.html#aeb549ff03b351397f4c7bded24d55e7c">clone_with_shared_params</a> (const <a class="el" href="classcattle_1_1_layer.html">Layer</a>&lt; Scalar, Rank &gt; &amp;layer)</td></tr>
<tr class="memdesc:aeb549ff03b351397f4c7bded24d55e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A method to expose protected methods of the <a class="el" href="classcattle_1_1_layer.html" title="An abstract class template representing layers in a neural network. ">Layer</a> class to subclasses of <a class="el" href="classcattle_1_1_neural_network.html" title="An abstract neural network class template. ">NeuralNetwork</a> that are not friend classes of <a class="el" href="classcattle_1_1_layer.html" title="An abstract class template representing layers in a neural network. ">Layer</a>.  <a href="#aeb549ff03b351397f4c7bded24d55e7c">More...</a><br /></td></tr>
<tr class="separator:aeb549ff03b351397f4c7bded24d55e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cdd26677f188f7c499f520a01082b60"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_neural_network.html#a6cdd26677f188f7c499f520a01082b60">set_input_layer</a> (<a class="el" href="classcattle_1_1_layer.html">Layer</a>&lt; Scalar, Rank &gt; &amp;layer, bool on)</td></tr>
<tr class="memdesc:a6cdd26677f188f7c499f520a01082b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">A method to expose protected methods of the <a class="el" href="classcattle_1_1_layer.html" title="An abstract class template representing layers in a neural network. ">Layer</a> class to subclasses of <a class="el" href="classcattle_1_1_neural_network.html" title="An abstract neural network class template. ">NeuralNetwork</a> that are not friend classes of <a class="el" href="classcattle_1_1_layer.html" title="An abstract class template representing layers in a neural network. ">Layer</a>.  <a href="#a6cdd26677f188f7c499f520a01082b60">More...</a><br /></td></tr>
<tr class="separator:a6cdd26677f188f7c499f520a01082b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417cb77f47eab00bb62f2f5347aff86f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_neural_network.html#a417cb77f47eab00bb62f2f5347aff86f">empty_cache</a> (<a class="el" href="classcattle_1_1_layer.html">Layer</a>&lt; Scalar, Rank &gt; &amp;layer)</td></tr>
<tr class="memdesc:a417cb77f47eab00bb62f2f5347aff86f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A method to expose protected methods of the <a class="el" href="classcattle_1_1_layer.html" title="An abstract class template representing layers in a neural network. ">Layer</a> class to subclasses of <a class="el" href="classcattle_1_1_neural_network.html" title="An abstract neural network class template. ">NeuralNetwork</a> that are not friend classes of <a class="el" href="classcattle_1_1_layer.html" title="An abstract class template representing layers in a neural network. ">Layer</a>.  <a href="#a417cb77f47eab00bb62f2f5347aff86f">More...</a><br /></td></tr>
<tr class="separator:a417cb77f47eab00bb62f2f5347aff86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7daf5b9eb47ba2c78c05928a39799cc0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacecattle.html#a8b9323ad928764340e46f0802bf27fbb">Tensor</a>&lt; Scalar, Rank+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_neural_network.html#a7daf5b9eb47ba2c78c05928a39799cc0">pass_forward</a> (<a class="el" href="classcattle_1_1_layer.html">Layer</a>&lt; Scalar, Rank &gt; &amp;layer, <a class="el" href="namespacecattle.html#a8b9323ad928764340e46f0802bf27fbb">Tensor</a>&lt; Scalar, Rank+1 &gt; prev_out, bool training)</td></tr>
<tr class="memdesc:a7daf5b9eb47ba2c78c05928a39799cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A method to expose protected methods of the <a class="el" href="classcattle_1_1_layer.html" title="An abstract class template representing layers in a neural network. ">Layer</a> class to subclasses of <a class="el" href="classcattle_1_1_neural_network.html" title="An abstract neural network class template. ">NeuralNetwork</a> that are not friend classes of <a class="el" href="classcattle_1_1_layer.html" title="An abstract class template representing layers in a neural network. ">Layer</a>.  <a href="#a7daf5b9eb47ba2c78c05928a39799cc0">More...</a><br /></td></tr>
<tr class="separator:a7daf5b9eb47ba2c78c05928a39799cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc39ba2e29abb0ab2e34e26dea38f02"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacecattle.html#a8b9323ad928764340e46f0802bf27fbb">Tensor</a>&lt; Scalar, Rank+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_neural_network.html#aabc39ba2e29abb0ab2e34e26dea38f02">pass_back</a> (<a class="el" href="classcattle_1_1_layer.html">Layer</a>&lt; Scalar, Rank &gt; &amp;layer, <a class="el" href="namespacecattle.html#a8b9323ad928764340e46f0802bf27fbb">Tensor</a>&lt; Scalar, Rank+1 &gt; out_grad)</td></tr>
<tr class="memdesc:aabc39ba2e29abb0ab2e34e26dea38f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">A method to expose protected methods of the <a class="el" href="classcattle_1_1_layer.html" title="An abstract class template representing layers in a neural network. ">Layer</a> class to subclasses of <a class="el" href="classcattle_1_1_neural_network.html" title="An abstract neural network class template. ">NeuralNetwork</a> that are not friend classes of <a class="el" href="classcattle_1_1_layer.html" title="An abstract class template representing layers in a neural network. ">Layer</a>.  <a href="#aabc39ba2e29abb0ab2e34e26dea38f02">More...</a><br /></td></tr>
<tr class="separator:aabc39ba2e29abb0ab2e34e26dea38f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b361839ba75dd77dd4f5cc02323d7d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacecattle.html#a1d78623a47279d516750a44dbad6090b">Matrix</a>&lt; Scalar &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_neural_network.html#a64b361839ba75dd77dd4f5cc02323d7d">get_params_grad</a> (<a class="el" href="classcattle_1_1_layer.html">Layer</a>&lt; Scalar, Rank &gt; &amp;layer)</td></tr>
<tr class="memdesc:a64b361839ba75dd77dd4f5cc02323d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A method to expose protected methods of the <a class="el" href="classcattle_1_1_layer.html" title="An abstract class template representing layers in a neural network. ">Layer</a> class to subclasses of <a class="el" href="classcattle_1_1_neural_network.html" title="An abstract neural network class template. ">NeuralNetwork</a> that are not friend classes of <a class="el" href="classcattle_1_1_layer.html" title="An abstract class template representing layers in a neural network. ">Layer</a>.  <a href="#a64b361839ba75dd77dd4f5cc02323d7d">More...</a><br /></td></tr>
<tr class="separator:a64b361839ba75dd77dd4f5cc02323d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Scalar, std::size_t Rank, bool Sequential&gt;<br />
class cattle::NeuralNetwork&lt; Scalar, Rank, Sequential &gt;</h3>

<p>An abstract neural network class template. </p>
<p>It allows for inference and training via back-propagation. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a550bd7dea6ddac56160b5cafd54e8962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a550bd7dea6ddac56160b5cafd54e8962">&#9670;&nbsp;</a></span>backpropagate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, std::size_t Rank, bool Sequential&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Data <a class="el" href="classcattle_1_1_neural_network.html">cattle::NeuralNetwork</a>&lt; Scalar, Rank, Sequential &gt;::backpropagate </td>
          <td>(</td>
          <td class="paramtype">Data&#160;</td>
          <td class="paramname"><em>out_grad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>It back-propagates the derivative of the loss function w.r.t. </p>
<p>the output of the network through its layers updating the gradients on their parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_grad</td><td>The derivative of the loss function w.r.t. the output of the network. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The derivative of the loss function w.r.t. the input of the network or a null tensor if the network is a foremost network. </dd></dl>

<p>Implemented in <a class="el" href="classcattle_1_1_bidirectional_neural_network.html#aa8fd84ef4bcc7d1a4ab5e7eecfb25340">cattle::BidirectionalNeuralNetwork&lt; Scalar, Rank, MergeType &gt;</a>, <a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html#a84a6425deae97b7a267628eb4c4dd251">cattle::LSTMNeuralNetwork&lt; Scalar, Rank, MulInt, Stateful &gt;</a>, <a class="el" href="classcattle_1_1_recurrent_neural_network.html#a9205a3e4630f5cb56ee61114aa7cf573">cattle::RecurrentNeuralNetwork&lt; Scalar, Rank, MulInt, Stateful &gt;</a>, <a class="el" href="classcattle_1_1_temporal_neural_network.html#a9cf15d87946e9258eb9b35a09cba565b">cattle::TemporalNeuralNetwork&lt; Scalar, Rank &gt;</a>, <a class="el" href="classcattle_1_1_sequential_neural_network.html#a3f563421af1948326e45eba47a01c787">cattle::SequentialNeuralNetwork&lt; Scalar, Rank &gt;</a>, <a class="el" href="classcattle_1_1_dense_neural_network.html#a2db9af58247ba4ebe9e0cb90bbdb6061">cattle::DenseNeuralNetwork&lt; Scalar, Rank, ConcatType &gt;</a>, <a class="el" href="classcattle_1_1_residual_neural_network.html#a0390a01783aaf57eb4d8eb30a3bf3bab">cattle::ResidualNeuralNetwork&lt; Scalar, Rank &gt;</a>, <a class="el" href="classcattle_1_1_parallel_neural_network.html#ae37c6343401fdb609b9a36f622c0e146">cattle::ParallelNeuralNetwork&lt; Scalar, Rank, MergeType &gt;</a>, <a class="el" href="classcattle_1_1_stacked_neural_network.html#ae191f3087164908ae0a52bf3c07ba99b">cattle::StackedNeuralNetwork&lt; Scalar, Rank, Sequential &gt;</a>, and <a class="el" href="classcattle_1_1_feedforward_neural_network.html#afeb45e4af8a6ed14f0ace826c9fdee20">cattle::FeedforwardNeuralNetwork&lt; Scalar, Rank &gt;</a>.</p>

</div>
</div>
<a id="a2abd58d4e18caa4ae95563da19c8338b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2abd58d4e18caa4ae95563da19c8338b">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, std::size_t Rank, bool Sequential&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcattle_1_1_neural_network.html">NeuralNetwork</a>&lt;Scalar,Rank,Sequential&gt;* <a class="el" href="classcattle_1_1_neural_network.html">cattle::NeuralNetwork</a>&lt; Scalar, Rank, Sequential &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A constant method implementing the clone pattern. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a copy of the instance. The instance does not take ownership of the returned pointer (i.e. the caller is responsible for deleting it). </dd></dl>

<p>Implemented in <a class="el" href="classcattle_1_1_bidirectional_neural_network.html#ac3200af26b657df73ee81b230d710fa6">cattle::BidirectionalNeuralNetwork&lt; Scalar, Rank, MergeType &gt;</a>, <a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html#acfe39bea97e1f01279024a8d2a2adbba">cattle::LSTMNeuralNetwork&lt; Scalar, Rank, MulInt, Stateful &gt;</a>, <a class="el" href="classcattle_1_1_recurrent_neural_network.html#a24cdf0e19a4704b59d22d23ec371e6c3">cattle::RecurrentNeuralNetwork&lt; Scalar, Rank, MulInt, Stateful &gt;</a>, <a class="el" href="classcattle_1_1_temporal_neural_network.html#ae1a9278f0cf149cee3f5e9f077fd8bfb">cattle::TemporalNeuralNetwork&lt; Scalar, Rank &gt;</a>, <a class="el" href="classcattle_1_1_sequential_neural_network.html#ab66f9630a90d2098bdefee44e4afc29b">cattle::SequentialNeuralNetwork&lt; Scalar, Rank &gt;</a>, <a class="el" href="classcattle_1_1_dense_neural_network.html#a42a9bae4ecdbd18ba5dabe3f73eacc57">cattle::DenseNeuralNetwork&lt; Scalar, Rank, ConcatType &gt;</a>, <a class="el" href="classcattle_1_1_residual_neural_network.html#a88ddc363dd51b731194a5cd00f940ac5">cattle::ResidualNeuralNetwork&lt; Scalar, Rank &gt;</a>, <a class="el" href="classcattle_1_1_parallel_neural_network.html#a8a0293c70c8583ca3446f9ef7998852f">cattle::ParallelNeuralNetwork&lt; Scalar, Rank, MergeType &gt;</a>, <a class="el" href="classcattle_1_1_stacked_neural_network.html#ae59cff8422eeeb2bc3d0f95f8ea3dcf8">cattle::StackedNeuralNetwork&lt; Scalar, Rank, Sequential &gt;</a>, and <a class="el" href="classcattle_1_1_feedforward_neural_network.html#ab0366180102ce798b97bf28634523a3c">cattle::FeedforwardNeuralNetwork&lt; Scalar, Rank &gt;</a>.</p>

</div>
</div>
<a id="aeb549ff03b351397f4c7bded24d55e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb549ff03b351397f4c7bded24d55e7c">&#9670;&nbsp;</a></span>clone_with_shared_params()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, std::size_t Rank, bool Sequential&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcattle_1_1_layer.html">Layer</a>&lt;Scalar,Rank&gt;* <a class="el" href="classcattle_1_1_neural_network.html">cattle::NeuralNetwork</a>&lt; Scalar, Rank, Sequential &gt;::clone_with_shared_params </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcattle_1_1_layer.html">Layer</a>&lt; Scalar, Rank &gt; &amp;&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A method to expose protected methods of the <a class="el" href="classcattle_1_1_layer.html" title="An abstract class template representing layers in a neural network. ">Layer</a> class to subclasses of <a class="el" href="classcattle_1_1_neural_network.html" title="An abstract neural network class template. ">NeuralNetwork</a> that are not friend classes of <a class="el" href="classcattle_1_1_layer.html" title="An abstract class template representing layers in a neural network. ">Layer</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcattle_1_1_layer.html#a725b8784f71f40c162f25a8820c97473" title="It returns a clone of the layer instance using a reference to the original&#39;s parameters. ">Layer::clone_with_shared_params()</a></dd></dl>
<p>It produces a clone of the specified layer that shares the original layer's parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>A reference to the layer to clone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the clone that uses a reference to the original layer's parameters. </dd></dl>

</div>
</div>
<a id="a417cb77f47eab00bb62f2f5347aff86f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417cb77f47eab00bb62f2f5347aff86f">&#9670;&nbsp;</a></span>empty_cache()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, std::size_t Rank, bool Sequential&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcattle_1_1_neural_network.html">cattle::NeuralNetwork</a>&lt; Scalar, Rank, Sequential &gt;::empty_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcattle_1_1_layer.html">Layer</a>&lt; Scalar, Rank &gt; &amp;&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A method to expose protected methods of the <a class="el" href="classcattle_1_1_layer.html" title="An abstract class template representing layers in a neural network. ">Layer</a> class to subclasses of <a class="el" href="classcattle_1_1_neural_network.html" title="An abstract neural network class template. ">NeuralNetwork</a> that are not friend classes of <a class="el" href="classcattle_1_1_layer.html" title="An abstract class template representing layers in a neural network. ">Layer</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcattle_1_1_layer.html#ae3d00e9fb6079e4b4990b3a14625a93d" title="It empties the layer&#39;s caches such as those required for the derivation of the function represented b...">Layer::empty_cache()</a></dd></dl>
<p>It empties the cache of the layer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The layer whose cache is to be emptied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acbea7d3cad12acbd2728e092acba4a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbea7d3cad12acbd2728e092acba4a25">&#9670;&nbsp;</a></span>get_input_dims()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, std::size_t Rank, bool Sequential&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classcattle_1_1_dimensions.html">Dims</a>&amp; <a class="el" href="classcattle_1_1_neural_network.html">cattle::NeuralNetwork</a>&lt; Scalar, Rank, Sequential &gt;::get_input_dims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the member variable denoting the dimensions of the tensors accepted by the network as its input along (except for the first rank which denotes the variable sample size and in case of sequential networks the second rank which denotes the variable time steps). </dd></dl>

<p>Implemented in <a class="el" href="classcattle_1_1_bidirectional_neural_network.html#aeb9d32ff0cc9163beb470f234cc10537">cattle::BidirectionalNeuralNetwork&lt; Scalar, Rank, MergeType &gt;</a>, <a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html#a515956ee97a9f94a2a9001f5ae4bedbf">cattle::LSTMNeuralNetwork&lt; Scalar, Rank, MulInt, Stateful &gt;</a>, <a class="el" href="classcattle_1_1_recurrent_neural_network.html#aa570e1c7a8baa09fbee96aa9457050dd">cattle::RecurrentNeuralNetwork&lt; Scalar, Rank, MulInt, Stateful &gt;</a>, <a class="el" href="classcattle_1_1_temporal_neural_network.html#a4ffd1652ef5a95f4bae59cde848fb5f6">cattle::TemporalNeuralNetwork&lt; Scalar, Rank &gt;</a>, <a class="el" href="classcattle_1_1_sequential_neural_network.html#a3df5a5b6dbef9435892a1aa99824ade7">cattle::SequentialNeuralNetwork&lt; Scalar, Rank &gt;</a>, <a class="el" href="classcattle_1_1_dense_neural_network.html#a41ea1fdfe22d99e945498a0c3e6acf6a">cattle::DenseNeuralNetwork&lt; Scalar, Rank, ConcatType &gt;</a>, <a class="el" href="classcattle_1_1_residual_neural_network.html#a1ef5456c5aa0121408223fdc565980aa">cattle::ResidualNeuralNetwork&lt; Scalar, Rank &gt;</a>, <a class="el" href="classcattle_1_1_parallel_neural_network.html#a5b60c593e8982b4b7e0d4d24b1aee236">cattle::ParallelNeuralNetwork&lt; Scalar, Rank, MergeType &gt;</a>, <a class="el" href="classcattle_1_1_stacked_neural_network.html#ac251af758479538ce72fc29847b66243">cattle::StackedNeuralNetwork&lt; Scalar, Rank, Sequential &gt;</a>, and <a class="el" href="classcattle_1_1_feedforward_neural_network.html#ab3f908cbb820dd15f81a35400b535e83">cattle::FeedforwardNeuralNetwork&lt; Scalar, Rank &gt;</a>.</p>

</div>
</div>
<a id="a297039d2fff23643c9b73da7b4bb686c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297039d2fff23643c9b73da7b4bb686c">&#9670;&nbsp;</a></span>get_layers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, std::size_t Rank, bool Sequential&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;<a class="el" href="classcattle_1_1_layer.html">Layer</a>&lt;Scalar,Rank&gt;*&gt; <a class="el" href="classcattle_1_1_neural_network.html">cattle::NeuralNetwork</a>&lt; Scalar, Rank, Sequential &gt;::get_layers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A vector of pointers to the layers of the network. The ownership of the layers remains with the network. </dd></dl>

<p>Implemented in <a class="el" href="classcattle_1_1_bidirectional_neural_network.html#a052fff2227a28520de4ef74cd8f45352">cattle::BidirectionalNeuralNetwork&lt; Scalar, Rank, MergeType &gt;</a>, <a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html#a24d781209f6bee0f3c837e625bbf5ea7">cattle::LSTMNeuralNetwork&lt; Scalar, Rank, MulInt, Stateful &gt;</a>, <a class="el" href="classcattle_1_1_recurrent_neural_network.html#a4938ecae0c0430d75f7f57e732a10c8b">cattle::RecurrentNeuralNetwork&lt; Scalar, Rank, MulInt, Stateful &gt;</a>, <a class="el" href="classcattle_1_1_temporal_neural_network.html#a0e79f22912e3f674996cfd7963c1d6ea">cattle::TemporalNeuralNetwork&lt; Scalar, Rank &gt;</a>, <a class="el" href="classcattle_1_1_sequential_neural_network.html#a06a64771c62b5cc3bd29d5f17c7001fc">cattle::SequentialNeuralNetwork&lt; Scalar, Rank &gt;</a>, <a class="el" href="classcattle_1_1_dense_neural_network.html#a850b7575f27f5e62f79d57d7d21af572">cattle::DenseNeuralNetwork&lt; Scalar, Rank, ConcatType &gt;</a>, <a class="el" href="classcattle_1_1_residual_neural_network.html#aecb8f6aae961b444b10d7bc04589ce2d">cattle::ResidualNeuralNetwork&lt; Scalar, Rank &gt;</a>, <a class="el" href="classcattle_1_1_parallel_neural_network.html#a5a9722d13ece51610438246ae9ead068">cattle::ParallelNeuralNetwork&lt; Scalar, Rank, MergeType &gt;</a>, <a class="el" href="classcattle_1_1_stacked_neural_network.html#accddb2bca5e1f6cc139c48d6e7717742">cattle::StackedNeuralNetwork&lt; Scalar, Rank, Sequential &gt;</a>, and <a class="el" href="classcattle_1_1_feedforward_neural_network.html#a4dee4c598b4ebc8c62c00af5c38b790a">cattle::FeedforwardNeuralNetwork&lt; Scalar, Rank &gt;</a>.</p>

</div>
</div>
<a id="abae4c549cee2b29c2b6e072ce0314303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae4c549cee2b29c2b6e072ce0314303">&#9670;&nbsp;</a></span>get_output_dims()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, std::size_t Rank, bool Sequential&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classcattle_1_1_dimensions.html">Dims</a>&amp; <a class="el" href="classcattle_1_1_neural_network.html">cattle::NeuralNetwork</a>&lt; Scalar, Rank, Sequential &gt;::get_output_dims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the member variable denoting the dimensions of the tensors output by the network (except for the first rank which denotes the variable sample size and in case of sequential networks the second rank which denotes the variable time steps). </dd></dl>

<p>Implemented in <a class="el" href="classcattle_1_1_bidirectional_neural_network.html#aac567c95a4dd332dd2239c5a6714bc75">cattle::BidirectionalNeuralNetwork&lt; Scalar, Rank, MergeType &gt;</a>, <a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html#ae10aa3773f5b55532301a6301d9d2cad">cattle::LSTMNeuralNetwork&lt; Scalar, Rank, MulInt, Stateful &gt;</a>, <a class="el" href="classcattle_1_1_recurrent_neural_network.html#a65378382938c173044d138d1fe35f84e">cattle::RecurrentNeuralNetwork&lt; Scalar, Rank, MulInt, Stateful &gt;</a>, <a class="el" href="classcattle_1_1_temporal_neural_network.html#a803ab73ed3f225fa7cd404b5f1947f4f">cattle::TemporalNeuralNetwork&lt; Scalar, Rank &gt;</a>, <a class="el" href="classcattle_1_1_sequential_neural_network.html#aea6d5fd31e744bae0faee3fcec5b9114">cattle::SequentialNeuralNetwork&lt; Scalar, Rank &gt;</a>, <a class="el" href="classcattle_1_1_dense_neural_network.html#acaeefc0dd5a374061d25b5f1e02eb434">cattle::DenseNeuralNetwork&lt; Scalar, Rank, ConcatType &gt;</a>, <a class="el" href="classcattle_1_1_residual_neural_network.html#adc9105475aaa8dc60782bc6d6607a766">cattle::ResidualNeuralNetwork&lt; Scalar, Rank &gt;</a>, <a class="el" href="classcattle_1_1_parallel_neural_network.html#a10e0039aa177ae89c690d962a871fa93">cattle::ParallelNeuralNetwork&lt; Scalar, Rank, MergeType &gt;</a>, <a class="el" href="classcattle_1_1_stacked_neural_network.html#a68836fa59e256e0dde0958b156f72588">cattle::StackedNeuralNetwork&lt; Scalar, Rank, Sequential &gt;</a>, and <a class="el" href="classcattle_1_1_feedforward_neural_network.html#a5776c02f5fe06b1fad8d34db93c6448f">cattle::FeedforwardNeuralNetwork&lt; Scalar, Rank &gt;</a>.</p>

</div>
</div>
<a id="a64b361839ba75dd77dd4f5cc02323d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b361839ba75dd77dd4f5cc02323d7d">&#9670;&nbsp;</a></span>get_params_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, std::size_t Rank, bool Sequential&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacecattle.html#a1d78623a47279d516750a44dbad6090b">Matrix</a>&lt;Scalar&gt;&amp; <a class="el" href="classcattle_1_1_neural_network.html">cattle::NeuralNetwork</a>&lt; Scalar, Rank, Sequential &gt;::get_params_grad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcattle_1_1_layer.html">Layer</a>&lt; Scalar, Rank &gt; &amp;&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A method to expose protected methods of the <a class="el" href="classcattle_1_1_layer.html" title="An abstract class template representing layers in a neural network. ">Layer</a> class to subclasses of <a class="el" href="classcattle_1_1_neural_network.html" title="An abstract neural network class template. ">NeuralNetwork</a> that are not friend classes of <a class="el" href="classcattle_1_1_layer.html" title="An abstract class template representing layers in a neural network. ">Layer</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcattle_1_1_layer.html#a6e2e726f9677758ea61c6916a5c88b92" title="It returns a reference to the gradient of the learnable parameters of the layer. ">Layer::get_params_grad()</a></dd></dl>
<p>It returns a non-constant reference to the gradient of the specified layer's parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The layer whose parameters' gradient is to be fetched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-constant reference to the gradient of the layer's parameters. </dd></dl>

</div>
</div>
<a id="ac88007e2f8fa2a208de0e51c8ac422cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac88007e2f8fa2a208de0e51c8ac422cc">&#9670;&nbsp;</a></span>infer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, std::size_t Rank, bool Sequential&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Data <a class="el" href="classcattle_1_1_neural_network.html">cattle::NeuralNetwork</a>&lt; Scalar, Rank, Sequential &gt;::infer </td>
          <td>(</td>
          <td class="paramtype">Data&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>It propagates the input through the neural network and outputs its prediction according to its current parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input to be mapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inference/prediction of the neural network. </dd></dl>

</div>
</div>
<a id="a5dadb8900281afff9167f02b2d75c86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dadb8900281afff9167f02b2d75c86a">&#9670;&nbsp;</a></span>is_foremost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, std::size_t Rank, bool Sequential&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classcattle_1_1_neural_network.html">cattle::NeuralNetwork</a>&lt; Scalar, Rank, Sequential &gt;::is_foremost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Whether the instance is a foremost network. If the instance is not a stand-alone network and it is not the first module of a complex network, it is not a foremost network. Foremost networks do not need to back-propagate the gradients all the way given that no other network is expected to depend on them. </dd></dl>

<p>Implemented in <a class="el" href="classcattle_1_1_bidirectional_neural_network.html#a2cd4e95bebb7272f37371f635bb09466">cattle::BidirectionalNeuralNetwork&lt; Scalar, Rank, MergeType &gt;</a>, <a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html#a746769e064f987a44c14c555123a9f6a">cattle::LSTMNeuralNetwork&lt; Scalar, Rank, MulInt, Stateful &gt;</a>, <a class="el" href="classcattle_1_1_recurrent_neural_network.html#ab3790738cc9ac1b654a2e357465d0ce1">cattle::RecurrentNeuralNetwork&lt; Scalar, Rank, MulInt, Stateful &gt;</a>, <a class="el" href="classcattle_1_1_temporal_neural_network.html#a926791c017ace19739b5b2e08cc8508e">cattle::TemporalNeuralNetwork&lt; Scalar, Rank &gt;</a>, <a class="el" href="classcattle_1_1_sequential_neural_network.html#a1d8c8f0f42d9252b0885bcf3cca5814f">cattle::SequentialNeuralNetwork&lt; Scalar, Rank &gt;</a>, <a class="el" href="classcattle_1_1_dense_neural_network.html#a33fefd1e2488d31481a3c9671afa1864">cattle::DenseNeuralNetwork&lt; Scalar, Rank, ConcatType &gt;</a>, <a class="el" href="classcattle_1_1_residual_neural_network.html#ab2c263bd9ab3332e7177ed9903110ac8">cattle::ResidualNeuralNetwork&lt; Scalar, Rank &gt;</a>, <a class="el" href="classcattle_1_1_parallel_neural_network.html#a5bd9cce2f1fbbd2dd87fd6ffcb2b1a52">cattle::ParallelNeuralNetwork&lt; Scalar, Rank, MergeType &gt;</a>, <a class="el" href="classcattle_1_1_stacked_neural_network.html#ae11949d45ac0a3aadb61ba5941f54162">cattle::StackedNeuralNetwork&lt; Scalar, Rank, Sequential &gt;</a>, and <a class="el" href="classcattle_1_1_feedforward_neural_network.html#a98b62db8eb004542ccff5f530b27fb7e">cattle::FeedforwardNeuralNetwork&lt; Scalar, Rank &gt;</a>.</p>

</div>
</div>
<a id="aabc39ba2e29abb0ab2e34e26dea38f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabc39ba2e29abb0ab2e34e26dea38f02">&#9670;&nbsp;</a></span>pass_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, std::size_t Rank, bool Sequential&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacecattle.html#a8b9323ad928764340e46f0802bf27fbb">Tensor</a>&lt;Scalar,Rank + 1&gt; <a class="el" href="classcattle_1_1_neural_network.html">cattle::NeuralNetwork</a>&lt; Scalar, Rank, Sequential &gt;::pass_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcattle_1_1_layer.html">Layer</a>&lt; Scalar, Rank &gt; &amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecattle.html#a8b9323ad928764340e46f0802bf27fbb">Tensor</a>&lt; Scalar, Rank+1 &gt;&#160;</td>
          <td class="paramname"><em>out_grad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A method to expose protected methods of the <a class="el" href="classcattle_1_1_layer.html" title="An abstract class template representing layers in a neural network. ">Layer</a> class to subclasses of <a class="el" href="classcattle_1_1_neural_network.html" title="An abstract neural network class template. ">NeuralNetwork</a> that are not friend classes of <a class="el" href="classcattle_1_1_layer.html" title="An abstract class template representing layers in a neural network. ">Layer</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcattle_1_1_layer.html#a7cb51862ef9b87632b5abb8e3ab36dd9" title="It back-propagates the derivative of the error function w.r.t. ">Layer::pass_back</a>(<a class="el" href="namespacecattle.html#a8b9323ad928764340e46f0802bf27fbb" title="An alias for a tensor of arbitrary rank and scalar type with dynamic dimensionality. ">Tensor</a>&lt;Scalar,Rank + 1&gt;)</dd></dl>
<p>It back-propagates the derivative of the loss function w.r.t. the output of the layer through the layer updating the gradients on its parameters along the way.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The layer through which the gradients are to be back-propagated. </td></tr>
    <tr><td class="paramname">out_grad</td><td>The derivative of the loss function w.r.t. the output of the layer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The derivative of the loss function w.r.t. the input of the layer or a null tensor if the layer is an input layer. </dd></dl>

</div>
</div>
<a id="a7daf5b9eb47ba2c78c05928a39799cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7daf5b9eb47ba2c78c05928a39799cc0">&#9670;&nbsp;</a></span>pass_forward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, std::size_t Rank, bool Sequential&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacecattle.html#a8b9323ad928764340e46f0802bf27fbb">Tensor</a>&lt;Scalar,Rank + 1&gt; <a class="el" href="classcattle_1_1_neural_network.html">cattle::NeuralNetwork</a>&lt; Scalar, Rank, Sequential &gt;::pass_forward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcattle_1_1_layer.html">Layer</a>&lt; Scalar, Rank &gt; &amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecattle.html#a8b9323ad928764340e46f0802bf27fbb">Tensor</a>&lt; Scalar, Rank+1 &gt;&#160;</td>
          <td class="paramname"><em>prev_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>training</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A method to expose protected methods of the <a class="el" href="classcattle_1_1_layer.html" title="An abstract class template representing layers in a neural network. ">Layer</a> class to subclasses of <a class="el" href="classcattle_1_1_neural_network.html" title="An abstract neural network class template. ">NeuralNetwork</a> that are not friend classes of <a class="el" href="classcattle_1_1_layer.html" title="An abstract class template representing layers in a neural network. ">Layer</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcattle_1_1_layer.html#a6c1ea7b25d9f882364b7f2288f02d8da" title="It has the function represented by the layer applied to the input tensor. ">Layer::pass_forward</a>(<a class="el" href="namespacecattle.html#a8b9323ad928764340e46f0802bf27fbb" title="An alias for a tensor of arbitrary rank and scalar type with dynamic dimensionality. ">Tensor</a>&lt;Scalar,Rank + 1&gt;,bool)</dd></dl>
<p>It propagates the input through the specified layer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The layer to which the input is to be fed. </td></tr>
    <tr><td class="paramname">prev_out</td><td>The input tensor. </td></tr>
    <tr><td class="paramname">training</td><td>Whether the input is to propagated through the layer in training mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output of the layer in response to the input. </dd></dl>

</div>
</div>
<a id="a6ade9cd95110766ff25e7b157c9fddcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ade9cd95110766ff25e7b157c9fddcf">&#9670;&nbsp;</a></span>propagate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, std::size_t Rank, bool Sequential&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Data <a class="el" href="classcattle_1_1_neural_network.html">cattle::NeuralNetwork</a>&lt; Scalar, Rank, Sequential &gt;::propagate </td>
          <td>(</td>
          <td class="paramtype">Data&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>training</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>It propagates the input tensor through the network and outputs its prediction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input tensor to propagate through. </td></tr>
    <tr><td class="paramname">training</td><td>Whether the input is to be propagated in training mode or not. Propagating the input in training mode may be more time and memory consuming, but is a prerequisite of back-propagation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output tensor of the network in response to the input. </dd></dl>

<p>Implemented in <a class="el" href="classcattle_1_1_bidirectional_neural_network.html#aeea3e43b89d4bdd0ac9b9e81c6815aa9">cattle::BidirectionalNeuralNetwork&lt; Scalar, Rank, MergeType &gt;</a>, <a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html#a06041a938c2b82c3cbbee3545e7f904f">cattle::LSTMNeuralNetwork&lt; Scalar, Rank, MulInt, Stateful &gt;</a>, <a class="el" href="classcattle_1_1_recurrent_neural_network.html#ad280f608bd81c202f82ab497e203e11e">cattle::RecurrentNeuralNetwork&lt; Scalar, Rank, MulInt, Stateful &gt;</a>, <a class="el" href="classcattle_1_1_temporal_neural_network.html#a6bc17e09f48f808a7e54a0d9ea7adfdb">cattle::TemporalNeuralNetwork&lt; Scalar, Rank &gt;</a>, <a class="el" href="classcattle_1_1_sequential_neural_network.html#a7938e9ded5e59b86b748a07d25b2a6b7">cattle::SequentialNeuralNetwork&lt; Scalar, Rank &gt;</a>, <a class="el" href="classcattle_1_1_dense_neural_network.html#a252b20495010a47ed646089564643a35">cattle::DenseNeuralNetwork&lt; Scalar, Rank, ConcatType &gt;</a>, <a class="el" href="classcattle_1_1_residual_neural_network.html#a2b3df37e544c34170dcdd8f30bd6ece7">cattle::ResidualNeuralNetwork&lt; Scalar, Rank &gt;</a>, <a class="el" href="classcattle_1_1_parallel_neural_network.html#a824cc55e65521f52e08c6d19768b7bb8">cattle::ParallelNeuralNetwork&lt; Scalar, Rank, MergeType &gt;</a>, <a class="el" href="classcattle_1_1_stacked_neural_network.html#ad0723d3b9577bda94b20bfdde66f5628">cattle::StackedNeuralNetwork&lt; Scalar, Rank, Sequential &gt;</a>, and <a class="el" href="classcattle_1_1_feedforward_neural_network.html#a5ba42a837437bbc9ed7d70e532107fe0">cattle::FeedforwardNeuralNetwork&lt; Scalar, Rank &gt;</a>.</p>

</div>
</div>
<a id="ae417618e6c761cf7630f24dff2d3568a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae417618e6c761cf7630f24dff2d3568a">&#9670;&nbsp;</a></span>set_foremost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, std::size_t Rank, bool Sequential&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcattle_1_1_neural_network.html">cattle::NeuralNetwork</a>&lt; Scalar, Rank, Sequential &gt;::set_foremost </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>foremost</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the foremost status of the network. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">foremost</td><td>Whether the network is to function as a foremost network. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classcattle_1_1_bidirectional_neural_network.html#a8c18a8cb33b287577ed9ce352b5acf0b">cattle::BidirectionalNeuralNetwork&lt; Scalar, Rank, MergeType &gt;</a>, <a class="el" href="classcattle_1_1_l_s_t_m_neural_network.html#a392e844c1364349e02be4b0ff8d20b02">cattle::LSTMNeuralNetwork&lt; Scalar, Rank, MulInt, Stateful &gt;</a>, <a class="el" href="classcattle_1_1_recurrent_neural_network.html#afa0abaa4d3214a0d57fa615f532093a2">cattle::RecurrentNeuralNetwork&lt; Scalar, Rank, MulInt, Stateful &gt;</a>, <a class="el" href="classcattle_1_1_temporal_neural_network.html#aad8acbb85b6f13facf1ae18d6df6fc84">cattle::TemporalNeuralNetwork&lt; Scalar, Rank &gt;</a>, <a class="el" href="classcattle_1_1_sequential_neural_network.html#a63f437f35a56ede3ebe43740ce91848d">cattle::SequentialNeuralNetwork&lt; Scalar, Rank &gt;</a>, <a class="el" href="classcattle_1_1_dense_neural_network.html#a960e0166e6c2478d6a500e977734671c">cattle::DenseNeuralNetwork&lt; Scalar, Rank, ConcatType &gt;</a>, <a class="el" href="classcattle_1_1_residual_neural_network.html#ac14610b19c5435b4d5b51c0c17bbaadf">cattle::ResidualNeuralNetwork&lt; Scalar, Rank &gt;</a>, <a class="el" href="classcattle_1_1_parallel_neural_network.html#a2adaa44fd77a423ef6f02079b53b5fa1">cattle::ParallelNeuralNetwork&lt; Scalar, Rank, MergeType &gt;</a>, <a class="el" href="classcattle_1_1_stacked_neural_network.html#a006e4355fe246933ce09711f704e1305">cattle::StackedNeuralNetwork&lt; Scalar, Rank, Sequential &gt;</a>, and <a class="el" href="classcattle_1_1_feedforward_neural_network.html#ac0bfbc604996f80bea099d0aba7c52f5">cattle::FeedforwardNeuralNetwork&lt; Scalar, Rank &gt;</a>.</p>

</div>
</div>
<a id="a94a8c8170471486c5f10ba09a5709ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a8c8170471486c5f10ba09a5709ad6">&#9670;&nbsp;</a></span>set_frozen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, std::size_t Rank, bool Sequential&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcattle_1_1_neural_network.html">cattle::NeuralNetwork</a>&lt; Scalar, Rank, Sequential &gt;::set_frozen </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>frozen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes the <a class="el" href="classcattle_1_1_layer.html#a2efa46d4b10ec998cb7b09a3c430e025" title="A method for setting whether the parameters of the layer should not be updated during optimization...">Layer::set_frozen(bool)</a> method of all layers of the network with the provided argument. </p>
<p>A frozen networks parameters are not regularized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frozen</td><td>Whether the parameters of all layers should be frozen (i.e. not updatable via optimization) or active. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6cdd26677f188f7c499f520a01082b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cdd26677f188f7c499f520a01082b60">&#9670;&nbsp;</a></span>set_input_layer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, std::size_t Rank, bool Sequential&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcattle_1_1_neural_network.html">cattle::NeuralNetwork</a>&lt; Scalar, Rank, Sequential &gt;::set_input_layer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcattle_1_1_layer.html">Layer</a>&lt; Scalar, Rank &gt; &amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A method to expose protected methods of the <a class="el" href="classcattle_1_1_layer.html" title="An abstract class template representing layers in a neural network. ">Layer</a> class to subclasses of <a class="el" href="classcattle_1_1_neural_network.html" title="An abstract neural network class template. ">NeuralNetwork</a> that are not friend classes of <a class="el" href="classcattle_1_1_layer.html" title="An abstract class template representing layers in a neural network. ">Layer</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcattle_1_1_layer.html#a9557e077d940b2ff0c280e9a78c4b52e" title="Sets this instance&#39;s input layer status to the given value. ">Layer::set_input_layer(bool)</a></dd></dl>
<p>It sets the specified layer's input-layer-status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The layer to modify. </td></tr>
    <tr><td class="paramname">on</td><td>Whether the layer is to function as an input layer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad216c4f30172a8924e959d103e38a82c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad216c4f30172a8924e959d103e38a82c">&#9670;&nbsp;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, std::size_t Rank, bool Sequential&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classcattle_1_1_neural_network.html">cattle::NeuralNetwork</a>&lt; Scalar, Rank, Sequential &gt;::to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A string representation of the neural network. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/Viktor/git/C-ATTL3/C-ATTL3/<a class="el" href="_layer_8hpp_source.html">Layer.hpp</a></li>
<li>C:/Users/Viktor/git/C-ATTL3/C-ATTL3/<a class="el" href="_neural_network_8hpp_source.html">NeuralNetwork.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
