<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C-ATTL3: cattle::BatchNormLayer&lt; Scalar, Rank &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C-ATTL3
   &#160;<span id="projectnumber">0.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecattle.html">cattle</a></li><li class="navelem"><a class="el" href="classcattle_1_1_batch_norm_layer.html">BatchNormLayer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classcattle_1_1_batch_norm_layer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cattle::BatchNormLayer&lt; Scalar, Rank &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class template for a batch normalization layer.  
 <a href="classcattle_1_1_batch_norm_layer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_layer_8hpp_source.html">Layer.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cattle::BatchNormLayer&lt; Scalar, Rank &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcattle_1_1_batch_norm_layer.png" usemap="#cattle::BatchNormLayer_3C_20Scalar_2C_20Rank_20_3E_map" alt=""/>
  <map id="cattle::BatchNormLayer_3C_20Scalar_2C_20Rank_20_3E_map" name="cattle::BatchNormLayer_3C_20Scalar_2C_20Rank_20_3E_map">
<area href="classcattle_1_1_batch_norm_layer_base.html" title="An abstract base class template for a batch normalization layer. " alt="cattle::BatchNormLayerBase&lt; Scalar, Rank &gt;" shape="rect" coords="0,56,269,80"/>
<area href="classcattle_1_1_layer.html" title="An abstract class template representing layers in a neural network. " alt="cattle::Layer&lt; Scalar, Rank &gt;" shape="rect" coords="0,0,269,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abb975e2f5e03ab7ac41437fa99e63e3c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_batch_norm_layer.html#abb975e2f5e03ab7ac41437fa99e63e3c">BatchNormLayer</a> (const <a class="el" href="classcattle_1_1_dimensions.html">Dimensions</a>&lt; std::size_t, Rank &gt; &amp;dims, <a class="el" href="namespacecattle.html#a083ab63c64a5c935b2d2cd3f03c4e27a">ParamRegSharedPtr</a>&lt; Scalar &gt; gamma_reg=Root::NO_PARAM_REG, <a class="el" href="namespacecattle.html#a083ab63c64a5c935b2d2cd3f03c4e27a">ParamRegSharedPtr</a>&lt; Scalar &gt; beta_reg=Root::NO_PARAM_REG, Scalar gamma_max_norm_constraint=0, Scalar beta_max_norm_constraint=0, Scalar norm_avg_decay=.1, Scalar epsilon=<a class="el" href="classcattle_1_1internal_1_1_numeric_utils.html">internal::NumericUtils</a>&lt; Scalar &gt;::EPSILON3)</td></tr>
<tr class="separator:abb975e2f5e03ab7ac41437fa99e63e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1812f43bb048fe50d23d8983fbc08a60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcattle_1_1_layer.html">Root</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_batch_norm_layer.html#a1812f43bb048fe50d23d8983fbc08a60">clone</a> () const</td></tr>
<tr class="memdesc:a1812f43bb048fe50d23d8983fbc08a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant method implementing the clone pattern.  <a href="#a1812f43bb048fe50d23d8983fbc08a60">More...</a><br /></td></tr>
<tr class="separator:a1812f43bb048fe50d23d8983fbc08a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcattle_1_1_batch_norm_layer_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcattle_1_1_batch_norm_layer_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcattle_1_1_batch_norm_layer_base.html">cattle::BatchNormLayerBase&lt; Scalar, Rank &gt;</a></td></tr>
<tr class="memitem:a2e69f13426905a8c2ed02bda0bc33ab8 inherit pub_methods_classcattle_1_1_batch_norm_layer_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcattle_1_1_dimensions.html">Dimensions</a>&lt; std::size_t, Rank &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_batch_norm_layer_base.html#a2e69f13426905a8c2ed02bda0bc33ab8">get_input_dims</a> () const</td></tr>
<tr class="memdesc:a2e69f13426905a8c2ed02bda0bc33ab8 inherit pub_methods_classcattle_1_1_batch_norm_layer_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple constant getter method for the input dimensionality of the layer.  <a href="classcattle_1_1_batch_norm_layer_base.html#a2e69f13426905a8c2ed02bda0bc33ab8">More...</a><br /></td></tr>
<tr class="separator:a2e69f13426905a8c2ed02bda0bc33ab8 inherit pub_methods_classcattle_1_1_batch_norm_layer_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c548711dd37518e24da9814841e5654 inherit pub_methods_classcattle_1_1_batch_norm_layer_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcattle_1_1_dimensions.html">Dimensions</a>&lt; std::size_t, Rank &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_batch_norm_layer_base.html#a0c548711dd37518e24da9814841e5654">get_output_dims</a> () const</td></tr>
<tr class="memdesc:a0c548711dd37518e24da9814841e5654 inherit pub_methods_classcattle_1_1_batch_norm_layer_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple constant getter method for the output dimensionality of the layer.  <a href="classcattle_1_1_batch_norm_layer_base.html#a0c548711dd37518e24da9814841e5654">More...</a><br /></td></tr>
<tr class="separator:a0c548711dd37518e24da9814841e5654 inherit pub_methods_classcattle_1_1_batch_norm_layer_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e1e98fdcdfca64ae43140d56c3bf9c inherit pub_methods_classcattle_1_1_batch_norm_layer_base"><td class="memItemLeft" align="right" valign="top"><a id="aa0e1e98fdcdfca64ae43140d56c3bf9c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_batch_norm_layer_base.html#aa0e1e98fdcdfca64ae43140d56c3bf9c">init</a> ()</td></tr>
<tr class="memdesc:aa0e1e98fdcdfca64ae43140d56c3bf9c inherit pub_methods_classcattle_1_1_batch_norm_layer_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">It initializes the layer and its parameters. <br /></td></tr>
<tr class="separator:aa0e1e98fdcdfca64ae43140d56c3bf9c inherit pub_methods_classcattle_1_1_batch_norm_layer_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcattle_1_1_layer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcattle_1_1_layer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcattle_1_1_layer.html">cattle::Layer&lt; Scalar, Rank &gt;</a></td></tr>
<tr class="memitem:a92963ac4a339d9174a3aef3dbf3c271f inherit pub_methods_classcattle_1_1_layer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_layer.html#a92963ac4a339d9174a3aef3dbf3c271f">is_parametric</a> ()</td></tr>
<tr class="memdesc:a92963ac4a339d9174a3aef3dbf3c271f inherit pub_methods_classcattle_1_1_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">A method that returns whether the layer has parameters that can be learned.  <a href="classcattle_1_1_layer.html#a92963ac4a339d9174a3aef3dbf3c271f">More...</a><br /></td></tr>
<tr class="separator:a92963ac4a339d9174a3aef3dbf3c271f inherit pub_methods_classcattle_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c19156cc41357b221b0b57633eaaca inherit pub_methods_classcattle_1_1_layer"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_layer.html#ab7c19156cc41357b221b0b57633eaaca">to_string</a> ()</td></tr>
<tr class="separator:ab7c19156cc41357b221b0b57633eaaca inherit pub_methods_classcattle_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a135142858f8e3433f7eeb67cde734e25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcattle_1_1_layer.html">Root</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_batch_norm_layer.html#a135142858f8e3433f7eeb67cde734e25">clone_with_shared_params</a> () const</td></tr>
<tr class="memdesc:a135142858f8e3433f7eeb67cde734e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns a clone of the layer instance using a reference to the original's parameters.  <a href="#a135142858f8e3433f7eeb67cde734e25">More...</a><br /></td></tr>
<tr class="separator:a135142858f8e3433f7eeb67cde734e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f18bd49ee2a8d50d6f4d1a51271c94a"><td class="memItemLeft" align="right" valign="top">Root::Data&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_batch_norm_layer.html#a3f18bd49ee2a8d50d6f4d1a51271c94a">pass_forward</a> (typename Root::Data in, bool training)</td></tr>
<tr class="memdesc:a3f18bd49ee2a8d50d6f4d1a51271c94a"><td class="mdescLeft">&#160;</td><td class="mdescRight">It has the function represented by the layer applied to the input tensor.  <a href="#a3f18bd49ee2a8d50d6f4d1a51271c94a">More...</a><br /></td></tr>
<tr class="separator:a3f18bd49ee2a8d50d6f4d1a51271c94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614b395b2e4b3a9b480ef344903eb74b"><td class="memItemLeft" align="right" valign="top">Root::Data&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_batch_norm_layer.html#a614b395b2e4b3a9b480ef344903eb74b">pass_back</a> (typename Root::Data out_grads)</td></tr>
<tr class="memdesc:a614b395b2e4b3a9b480ef344903eb74b"><td class="mdescLeft">&#160;</td><td class="mdescRight">It back-propagates the derivative of the error function w.r.t.  <a href="#a614b395b2e4b3a9b480ef344903eb74b">More...</a><br /></td></tr>
<tr class="separator:a614b395b2e4b3a9b480ef344903eb74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classcattle_1_1_batch_norm_layer_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classcattle_1_1_batch_norm_layer_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classcattle_1_1_batch_norm_layer_base.html">cattle::BatchNormLayerBase&lt; Scalar, Rank &gt;</a></td></tr>
<tr class="memitem:aa03b7850674b51b3e48b1436ef4f2b9b inherit pro_methods_classcattle_1_1_batch_norm_layer_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_batch_norm_layer_base.html#aa03b7850674b51b3e48b1436ef4f2b9b">is_input_layer</a> () const</td></tr>
<tr class="memdesc:aa03b7850674b51b3e48b1436ef4f2b9b inherit pro_methods_classcattle_1_1_batch_norm_layer_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant method that returns whether this layer functions as an input layer.  <a href="classcattle_1_1_batch_norm_layer_base.html#aa03b7850674b51b3e48b1436ef4f2b9b">More...</a><br /></td></tr>
<tr class="separator:aa03b7850674b51b3e48b1436ef4f2b9b inherit pro_methods_classcattle_1_1_batch_norm_layer_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183a44d3eab2fa0912f60b9dd16e7702 inherit pro_methods_classcattle_1_1_batch_norm_layer_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_batch_norm_layer_base.html#a183a44d3eab2fa0912f60b9dd16e7702">set_input_layer</a> (bool input_layer)</td></tr>
<tr class="memdesc:a183a44d3eab2fa0912f60b9dd16e7702 inherit pro_methods_classcattle_1_1_batch_norm_layer_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this instance's input layer status to the given value.  <a href="classcattle_1_1_batch_norm_layer_base.html#a183a44d3eab2fa0912f60b9dd16e7702">More...</a><br /></td></tr>
<tr class="separator:a183a44d3eab2fa0912f60b9dd16e7702 inherit pro_methods_classcattle_1_1_batch_norm_layer_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca777ac62f98c22b431ef92e0da2c903 inherit pro_methods_classcattle_1_1_batch_norm_layer_base"><td class="memItemLeft" align="right" valign="top"><a id="aca777ac62f98c22b431ef92e0da2c903"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_batch_norm_layer_base.html#aca777ac62f98c22b431ef92e0da2c903">empty_cache</a> ()</td></tr>
<tr class="memdesc:aca777ac62f98c22b431ef92e0da2c903 inherit pro_methods_classcattle_1_1_batch_norm_layer_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">It empties the layer's caches such as those required for the derivation of the function represented by the layer. <br /></td></tr>
<tr class="separator:aca777ac62f98c22b431ef92e0da2c903 inherit pro_methods_classcattle_1_1_batch_norm_layer_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51e553e1dc5be6b061b7b2a38686f6f inherit pro_methods_classcattle_1_1_batch_norm_layer_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecattle.html#a1d78623a47279d516750a44dbad6090b">Matrix</a>&lt; Scalar &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_batch_norm_layer_base.html#ae51e553e1dc5be6b061b7b2a38686f6f">get_params</a> ()</td></tr>
<tr class="memdesc:ae51e553e1dc5be6b061b7b2a38686f6f inherit pro_methods_classcattle_1_1_batch_norm_layer_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns a reference to the learnable parameters of the layer.  <a href="classcattle_1_1_batch_norm_layer_base.html#ae51e553e1dc5be6b061b7b2a38686f6f">More...</a><br /></td></tr>
<tr class="separator:ae51e553e1dc5be6b061b7b2a38686f6f inherit pro_methods_classcattle_1_1_batch_norm_layer_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeaa4b34bd86ec270705421ff20282fd inherit pro_methods_classcattle_1_1_batch_norm_layer_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecattle.html#a1d78623a47279d516750a44dbad6090b">Matrix</a>&lt; Scalar &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_batch_norm_layer_base.html#abeaa4b34bd86ec270705421ff20282fd">get_params_grad</a> ()</td></tr>
<tr class="memdesc:abeaa4b34bd86ec270705421ff20282fd inherit pro_methods_classcattle_1_1_batch_norm_layer_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">It returns a reference to the gradient of the learnable parameters of the layer.  <a href="classcattle_1_1_batch_norm_layer_base.html#abeaa4b34bd86ec270705421ff20282fd">More...</a><br /></td></tr>
<tr class="separator:abeaa4b34bd86ec270705421ff20282fd inherit pro_methods_classcattle_1_1_batch_norm_layer_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b9b07cc41521ee0828979e326d4d2a inherit pro_methods_classcattle_1_1_batch_norm_layer_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_batch_norm_layer_base.html#a68b9b07cc41521ee0828979e326d4d2a">regularize</a> ()</td></tr>
<tr class="memdesc:a68b9b07cc41521ee0828979e326d4d2a inherit pro_methods_classcattle_1_1_batch_norm_layer_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">It computes the derivative of the regularization function w.r.t.  <a href="classcattle_1_1_batch_norm_layer_base.html#a68b9b07cc41521ee0828979e326d4d2a">More...</a><br /></td></tr>
<tr class="separator:a68b9b07cc41521ee0828979e326d4d2a inherit pro_methods_classcattle_1_1_batch_norm_layer_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed073eae22a54cafa4366fd673878696 inherit pro_methods_classcattle_1_1_batch_norm_layer_base"><td class="memItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_batch_norm_layer_base.html#aed073eae22a54cafa4366fd673878696">get_regularization_penalty</a> ()</td></tr>
<tr class="memdesc:aed073eae22a54cafa4366fd673878696 inherit pro_methods_classcattle_1_1_batch_norm_layer_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">It calculates the regularization penalty of the layer's parameters.  <a href="classcattle_1_1_batch_norm_layer_base.html#aed073eae22a54cafa4366fd673878696">More...</a><br /></td></tr>
<tr class="separator:aed073eae22a54cafa4366fd673878696 inherit pro_methods_classcattle_1_1_batch_norm_layer_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437a4e58b66b1a917601ad27215f8614 inherit pro_methods_classcattle_1_1_batch_norm_layer_base"><td class="memItemLeft" align="right" valign="top"><a id="a437a4e58b66b1a917601ad27215f8614"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcattle_1_1_batch_norm_layer_base.html#a437a4e58b66b1a917601ad27215f8614">enforce_constraints</a> ()</td></tr>
<tr class="memdesc:a437a4e58b66b1a917601ad27215f8614 inherit pro_methods_classcattle_1_1_batch_norm_layer_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">It applies constraints such as max-norm to the parameters of the layer (if applicable). <br /></td></tr>
<tr class="separator:a437a4e58b66b1a917601ad27215f8614 inherit pro_methods_classcattle_1_1_batch_norm_layer_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Scalar, std::size_t Rank&gt;<br />
class cattle::BatchNormLayer&lt; Scalar, Rank &gt;</h3>

<p>A class template for a batch normalization layer. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abb975e2f5e03ab7ac41437fa99e63e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb975e2f5e03ab7ac41437fa99e63e3c">&#9670;&nbsp;</a></span>BatchNormLayer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, std::size_t Rank&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcattle_1_1_batch_norm_layer.html">cattle::BatchNormLayer</a>&lt; Scalar, Rank &gt;::<a class="el" href="classcattle_1_1_batch_norm_layer.html">BatchNormLayer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcattle_1_1_dimensions.html">Dimensions</a>&lt; std::size_t, Rank &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecattle.html#a083ab63c64a5c935b2d2cd3f03c4e27a">ParamRegSharedPtr</a>&lt; Scalar &gt;&#160;</td>
          <td class="paramname"><em>gamma_reg</em> = <code>Root::NO_PARAM_REG</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecattle.html#a083ab63c64a5c935b2d2cd3f03c4e27a">ParamRegSharedPtr</a>&lt; Scalar &gt;&#160;</td>
          <td class="paramname"><em>beta_reg</em> = <code>Root::NO_PARAM_REG</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>gamma_max_norm_constraint</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>beta_max_norm_constraint</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>norm_avg_decay</em> = <code>.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code><a class="el" href="classcattle_1_1internal_1_1_numeric_utils.html">internal::NumericUtils</a>&lt;Scalar&gt;::EPSILON3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>The dimensionality of the input tensor. </td></tr>
    <tr><td class="paramname">gamma_reg</td><td>The regularization function to apply to the layer's gamma parameters. </td></tr>
    <tr><td class="paramname">beta_reg</td><td>The regularization function to apply to the layer's beta parameters. </td></tr>
    <tr><td class="paramname">gamma_max_norm_constraint</td><td>An optional max-norm constraint to enforce on the gamma parameters. If it is 0 or less, no constraint is applied. </td></tr>
    <tr><td class="paramname">beta_max_norm_constraint</td><td>An optional max-norm constraint to enforce on the beta parameters. If it is 0 or less, no constraint is applied. </td></tr>
    <tr><td class="paramname">norm_avg_decay</td><td>The decay rate of the maintained means and variances. </td></tr>
    <tr><td class="paramname">epsilon</td><td>A small constant used to maintain numerical stability. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1812f43bb048fe50d23d8983fbc08a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1812f43bb048fe50d23d8983fbc08a60">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, std::size_t Rank&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcattle_1_1_layer.html">Root</a>* <a class="el" href="classcattle_1_1_batch_norm_layer.html">cattle::BatchNormLayer</a>&lt; Scalar, Rank &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A constant method implementing the clone pattern. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a copy of the instance. The instance does not take ownership of the returned pointer (i.e. the caller is responsible for deleting it). </dd></dl>

<p>Implements <a class="el" href="classcattle_1_1_layer.html#a46db46c62f3d46c6bbef5a482d7fcb00">cattle::Layer&lt; Scalar, Rank &gt;</a>.</p>

</div>
</div>
<a id="a135142858f8e3433f7eeb67cde734e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135142858f8e3433f7eeb67cde734e25">&#9670;&nbsp;</a></span>clone_with_shared_params()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, std::size_t Rank&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcattle_1_1_layer.html">Root</a>* <a class="el" href="classcattle_1_1_batch_norm_layer.html">cattle::BatchNormLayer</a>&lt; Scalar, Rank &gt;::clone_with_shared_params </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>It returns a clone of the layer instance using a reference to the original's parameters. </p>
<dl class="section return"><dt>Returns</dt><dd>A clone of the original layer instance sharing the same parameters with the original. </dd></dl>

<p>Implements <a class="el" href="classcattle_1_1_layer.html#a725b8784f71f40c162f25a8820c97473">cattle::Layer&lt; Scalar, Rank &gt;</a>.</p>

</div>
</div>
<a id="a614b395b2e4b3a9b480ef344903eb74b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614b395b2e4b3a9b480ef344903eb74b">&#9670;&nbsp;</a></span>pass_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, std::size_t Rank&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Root::Data <a class="el" href="classcattle_1_1_batch_norm_layer.html">cattle::BatchNormLayer</a>&lt; Scalar, Rank &gt;::pass_back </td>
          <td>(</td>
          <td class="paramtype">typename Root::Data&#160;</td>
          <td class="paramname"><em>out_grads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>It back-propagates the derivative of the error function w.r.t. </p>
<p>the output of the layer updating the gradient of its learnable parameters along the way if there are any. If there are, it also calculates the derivative of the regularization penalty w.r.t. to the layer's parameters and adds it to their gradient.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_grads</td><td>The derivative of the loss function w.r.t. the output of the layer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The derivative of the loss function w.r.t. the output of the previous layer or a null tensor if the layer is an input layer. </dd></dl>

<p>Implements <a class="el" href="classcattle_1_1_layer.html#a10194a9e1de70a94e0e30a4701d14c0f">cattle::Layer&lt; Scalar, Rank &gt;</a>.</p>

</div>
</div>
<a id="a3f18bd49ee2a8d50d6f4d1a51271c94a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f18bd49ee2a8d50d6f4d1a51271c94a">&#9670;&nbsp;</a></span>pass_forward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, std::size_t Rank&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Root::Data <a class="el" href="classcattle_1_1_batch_norm_layer.html">cattle::BatchNormLayer</a>&lt; Scalar, Rank &gt;::pass_forward </td>
          <td>(</td>
          <td class="paramtype">typename Root::Data&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>training</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>It has the function represented by the layer applied to the input tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>A tensor representing a batch of observations. The observations are of the rank specified by the layer's template parameter and the input tensors rank is one greater. </td></tr>
    <tr><td class="paramname">training</td><td>Whether the input is to be processed in training or inference mode. If the forward pass is performed in inference mode, the backward pass is not guaranteed to work. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output of the function represented by the layer applied to the input tensor. </dd></dl>

<p>Implements <a class="el" href="classcattle_1_1_layer.html#a6c1ea7b25d9f882364b7f2288f02d8da">cattle::Layer&lt; Scalar, Rank &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/Viktor/git/C-ATTL3/C-ATTL3/<a class="el" href="_layer_8hpp_source.html">Layer.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
